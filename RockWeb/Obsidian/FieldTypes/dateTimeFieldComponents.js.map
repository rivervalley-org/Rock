{"version":3,"file":"dateTimeFieldComponents.js","sources":["../../../Framework/FieldTypes/dateTimeField.partial.ts","../../../Framework/FieldTypes/dateTimeFieldComponents.ts"],"sourcesContent":["ï»¿// <copyright>\r\n// Copyright by the Spark Development Network\r\n//\r\n// Licensed under the Rock Community License (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n// http://www.rockrms.com/license\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n// </copyright>\r\n//\r\nimport { Component } from \"vue\";\r\nimport { defineAsyncComponent } from \"@Obsidian/Utility/component\";\r\nimport { ComparisonType } from \"@Obsidian/Enums/Reporting/comparisonType\";\r\nimport { dateComparisonTypes } from \"@Obsidian/Core/Reporting/comparisonType\";\r\nimport { ComparisonValue } from \"@Obsidian/Types/Reporting/comparisonValue\";\r\nimport { asBoolean } from \"@Obsidian/Utility/booleanUtils\";\r\nimport { toNumber } from \"@Obsidian/Utility/numberUtils\";\r\nimport { getRangeTypeText, getTimeUnitText, parseSlidingDateRangeString, RangeType, TimeUnit } from \"@Obsidian/Utility/slidingDateRange\";\r\nimport { RockDateTime } from \"@Obsidian/Utility/rockDateTime\";\r\nimport { FieldTypeBase } from \"./fieldType\";\r\nimport { getStandardFilterComponent } from \"./utils\";\r\n\r\nexport const enum ConfigurationValueKey {\r\n    Format = \"format\",\r\n    DisplayAsElapsedTime = \"displayDiff\",\r\n    DisplayCurrentOption = \"displayCurrentOption\"\r\n}\r\n\r\n\r\n// The edit component can be quite large, so load it only as needed.\r\nconst editComponent = defineAsyncComponent(async () => {\r\n    return (await import(\"./dateTimeFieldComponents\")).EditComponent;\r\n});\r\n\r\n// The configuration component can be quite large, so load it only as needed.\r\nconst configurationComponent = defineAsyncComponent(async () => {\r\n    return (await import(\"./dateTimeFieldComponents\")).ConfigurationComponent;\r\n});\r\n\r\n// Load the filter component as needed.\r\nconst filterComponent = defineAsyncComponent(async () => {\r\n    return (await import(\"./dateTimeFieldComponents\")).FilterComponent;\r\n});\r\n\r\n\r\n/**\r\n * The field type handler for the Date Time field.\r\n */\r\nexport class DateTimeFieldType extends FieldTypeBase {\r\n    public override getTextValue(value: string, configurationValues: Record<string, string>): string {\r\n        if (this.isCurrentDateValue(value)) {\r\n            return this.getCurrentDateText(value);\r\n        }\r\n        else if (value) {\r\n            const dateValue = RockDateTime.parseISO(value);\r\n            const dateFormatTemplate = configurationValues[ConfigurationValueKey.Format] || \"MM/dd/yyy\";\r\n\r\n            if (dateValue !== null) {\r\n                let textValue = dateValue.toASPString(dateFormatTemplate);\r\n\r\n                const displayDiff = asBoolean(configurationValues[ConfigurationValueKey.DisplayAsElapsedTime]);\r\n\r\n                if (displayDiff === true) {\r\n                    textValue = `${textValue} ${dateValue.toElapsedString()}`;\r\n                }\r\n\r\n                return textValue;\r\n            }\r\n            else {\r\n                return \"\";\r\n            }\r\n        }\r\n        else {\r\n            return \"\";\r\n        }\r\n    }\r\n\r\n    public override getEditComponent(): Component {\r\n        return editComponent;\r\n    }\r\n\r\n    public override getConfigurationComponent(): Component {\r\n        return configurationComponent;\r\n    }\r\n\r\n    public override getSupportedComparisonTypes(): ComparisonType {\r\n        return dateComparisonTypes;\r\n    }\r\n\r\n    public override getFilterComponent(): Component {\r\n        return getStandardFilterComponent(this.getSupportedComparisonTypes(), filterComponent, {\r\n            updateComparisonTypeNames: (options) => {\r\n                options.filter(o => o.value === ComparisonType.Between.toString())\r\n                    .forEach(o => o.text = \"Range\");\r\n            }\r\n        });\r\n    }\r\n\r\n    public override getFilterValueDescription(value: ComparisonValue, configurationValues: Record<string, string>): string {\r\n        if (value.comparisonType === ComparisonType.Between) {\r\n            return `During '${this.getFilterValueText(value, configurationValues)}'`;\r\n        }\r\n\r\n        return super.getFilterValueDescription(value, configurationValues);\r\n    }\r\n\r\n    public override getFilterValueText(value: ComparisonValue, _configurationValues: Record<string, string>): string {\r\n        const filterValues = value.value.split(\"\\t\");\r\n\r\n        // If the comparison type is Between, then we need to use the second\r\n        // value that was specified.\r\n        if (value.comparisonType === ComparisonType.Between && filterValues.length > 1) {\r\n            const range = parseSlidingDateRangeString(filterValues[1]);\r\n\r\n            // If we couldn't parse the range information then just return\r\n            // the raw value, which should be an empty string, but would give\r\n            // some indication that something is wrong if it isn't.\r\n            if (range === null) {\r\n                return filterValues[1];\r\n            }\r\n\r\n            // Get the calculated values from the SlidingDateRange.\r\n            const rangeTypeText = getRangeTypeText(range.rangeType);\r\n            const timeUnitValue = range.timeValue ?? 1;\r\n            const timeUnitText = getTimeUnitText(range.timeUnit ?? TimeUnit.Hour) + (timeUnitValue !== 1 ? \"s\" : \"\");\r\n\r\n            // Format the text depending on the range type.\r\n            if (range.rangeType === RangeType.Current) {\r\n                return `${rangeTypeText} ${timeUnitText}`;\r\n            }\r\n            else if (([RangeType.Last, RangeType.Previous, RangeType.Next, RangeType.Upcoming] as number[]).includes(range.rangeType)) {\r\n                return `${rangeTypeText} ${timeUnitValue} ${timeUnitText}`;\r\n            }\r\n            else {\r\n                if (range.lowerDate && range.upperDate) {\r\n                    return `${range.lowerDate} to ${range.upperDate}`;\r\n                }\r\n                else if (range.lowerDate) {\r\n                    return `from ${range.lowerDate}`;\r\n                }\r\n                else if (range.upperDate) {\r\n                    return `through ${range.upperDate}`;\r\n                }\r\n                else {\r\n                    return \"\";\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            // If it's not a between, check if it's a \"Current Date\" value.\r\n            if (this.isCurrentDateValue(filterValues[0])) {\r\n                return `'${this.getCurrentDateText(filterValues[0])}'`;\r\n            }\r\n\r\n            // Nope, just use the date value specified.\r\n            return filterValues[0] ? `'${filterValues[0]}'` : \"\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Determines if the value is a \"current date\" value, which would then\r\n     * specify the number of minutes +/- to adjust.\r\n     *\r\n     * @param value The value to be checked.\r\n     *\r\n     * @returns true if the value represents a \"current date\" value; otherwise false.\r\n     */\r\n    private isCurrentDateValue(value: string): boolean {\r\n        return value.indexOf(\"CURRENT\") === 0;\r\n    }\r\n\r\n    /**\r\n     * Get the text that describes the \"current date\" value specified.\r\n     *\r\n     * @param value The value that contains the \"current date\" value.\r\n     *\r\n     * @returns A human friendly description of the \"current date\" value.\r\n     */\r\n    private getCurrentDateText(value: string): string {\r\n        const parts = value.split(\":\");\r\n        const diff = parts.length === 2 ? toNumber(parts[1]) : 0;\r\n\r\n        if (diff === 1) {\r\n            return \"Current Time plus 1 minute\";\r\n        }\r\n        else if (diff > 0) {\r\n            return `Current Time plus ${diff} minutes`;\r\n        }\r\n        else if (diff === -1) {\r\n            return \"Current Time minus 1 minute\";\r\n        }\r\n        else if (diff < 0) {\r\n            return `Current Time minus ${Math.abs(diff)} minutes`;\r\n        }\r\n        else {\r\n            return \"Current Time\";\r\n        }\r\n    }\r\n}\r\n","// <copyright>\r\n// Copyright by the Spark Development Network\r\n//\r\n// Licensed under the Rock Community License (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n// http://www.rockrms.com/license\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n// </copyright>\r\n//\r\nimport { computed, defineComponent, PropType, ref, watch } from \"vue\";\r\nimport { getFieldEditorProps, getFieldConfigurationProps } from \"./utils\";\r\nimport { asBoolean, asTrueFalseOrNull } from \"@Obsidian/Utility/booleanUtils\";\r\nimport { ConfigurationValueKey } from \"./dateTimeField.partial\";\r\nimport SlidingDateRangePicker from \"@Obsidian/Controls/slidingDateRangePicker.obs\";\r\nimport DateTimePicker from \"@Obsidian/Controls/dateTimePicker\";\r\nimport TextBox from \"@Obsidian/Controls/textBox\";\r\nimport CheckBox from \"@Obsidian/Controls/checkBox\";\r\nimport { ComparisonType } from \"@Obsidian/Enums/Reporting/comparisonType\";\r\nimport { parseSlidingDateRangeString, slidingDateRangeToString } from \"@Obsidian/Utility/slidingDateRange\";\r\nimport { updateRefValue } from \"@Obsidian/Utility/component\";\r\n\r\nexport const EditComponent = defineComponent({\r\n    name: \"DateTimeField.Edit\",\r\n\r\n    components: {\r\n        DateTimePicker\r\n    },\r\n\r\n    props: getFieldEditorProps(),\r\n\r\n    setup() {\r\n        return {\r\n        };\r\n    },\r\n\r\n    data() {\r\n        return {\r\n            internalValue: \"\",\r\n            formattedString: \"\"\r\n        };\r\n    },\r\n\r\n    methods: {\r\n        async syncModelValue(): Promise<void> {\r\n            this.internalValue = this.modelValue ?? \"\";\r\n        },\r\n    },\r\n\r\n    computed: {\r\n        dateFormatTemplate(): string {\r\n            const formatConfig = this.configurationValues[ConfigurationValueKey.Format];\r\n            return formatConfig || \"MM/dd/yyyy\";\r\n        },\r\n\r\n        configAttributes(): Record<string, number | boolean> {\r\n            const attributes: Record<string, number | boolean> = {};\r\n\r\n            const displayCurrentConfig = this.configurationValues[ConfigurationValueKey.DisplayCurrentOption];\r\n            const displayCurrent = asBoolean(displayCurrentConfig);\r\n            attributes.displayCurrentOption = displayCurrent;\r\n            attributes.isCurrentDateOffset = displayCurrent;\r\n\r\n            return attributes;\r\n        }\r\n    },\r\n\r\n    watch: {\r\n        internalValue(): void {\r\n            if (this.internalValue !== this.modelValue) {\r\n                const d1 = Date.parse(this.internalValue);\r\n                const d2 = Date.parse(this.modelValue ?? \"\");\r\n\r\n                if (isNaN(d1) || isNaN(d2) || d1 !== d2) {\r\n                    this.$emit(\"update:modelValue\", this.internalValue);\r\n                }\r\n            }\r\n        },\r\n\r\n        modelValue: {\r\n            immediate: true,\r\n            async handler(): Promise<void> {\r\n                await this.syncModelValue();\r\n            }\r\n        }\r\n    },\r\n    template: `\r\n<DateTimePicker v-model=\"internalValue\" v-bind=\"configAttributes\" />\r\n`\r\n});\r\n\r\nexport const FilterComponent = defineComponent({\r\n    name: \"DateField.Filter\",\r\n\r\n    components: {\r\n        EditComponent,\r\n        SlidingDateRangePicker\r\n    },\r\n\r\n    props: {\r\n        ...getFieldEditorProps(),\r\n        comparisonType: {\r\n            type: Number as PropType<ComparisonType | null>,\r\n            required: true\r\n        }\r\n    },\r\n\r\n    emits: [\r\n        \"update:modelValue\"\r\n    ],\r\n\r\n    setup(props, { emit }) {\r\n        // The internal values that make up the model value.\r\n        const internalValue = ref(props.modelValue);\r\n        const internalValueSegments = internalValue.value.split(\"\\t\");\r\n        const dateValue = ref(internalValueSegments[0]);\r\n        const rangeValue = ref(parseSlidingDateRangeString(internalValueSegments.length > 1 ? internalValueSegments[1] : \"\"));\r\n\r\n        // Get the configuration values and force the DisplayCurrentOption to True.\r\n        const configurationValues = ref({ ...props.configurationValues });\r\n        configurationValues.value[ConfigurationValueKey.DisplayCurrentOption] = \"True\";\r\n\r\n        /** True if the comparison type is of type Between. */\r\n        const isComparisonTypeBetween = computed((): boolean => props.comparisonType === ComparisonType.Between);\r\n\r\n        // Watch for changes in the configuration values and update our own list.\r\n        watch(() => props.configurationValues, () => {\r\n            configurationValues.value = { ...props.configurationValues };\r\n            configurationValues.value[ConfigurationValueKey.DisplayCurrentOption] = \"True\";\r\n        });\r\n\r\n        // Watch for changes from the standard DatePicker.\r\n        watch(dateValue, () => {\r\n            if (props.comparisonType !== ComparisonType.Between) {\r\n                internalValue.value = `${dateValue.value}\\t`;\r\n            }\r\n        });\r\n\r\n        // Watch for changes from the SlidingDateRangePicker.\r\n        watch(rangeValue, () => {\r\n            if (props.comparisonType === ComparisonType.Between) {\r\n                internalValue.value = `\\t${rangeValue.value ? slidingDateRangeToString(rangeValue.value) : \"\"}`;\r\n            }\r\n        });\r\n\r\n        // Watch for changes to the model value and update our internal values.\r\n        watch(() => props.modelValue, () => {\r\n            internalValue.value = props.modelValue;\r\n            const segments = internalValue.value.split(\"\\t\");\r\n            dateValue.value = segments[0];\r\n            updateRefValue(rangeValue, parseSlidingDateRangeString(segments.length > 1 ? segments[1] : \"\"));\r\n        });\r\n\r\n        // Watch for changes to our internal value and update the model value.\r\n        watch(internalValue, () => {\r\n            emit(\"update:modelValue\", internalValue.value);\r\n        });\r\n\r\n        return {\r\n            configurationValues,\r\n            dateValue,\r\n            isComparisonTypeBetween,\r\n            rangeValue\r\n        };\r\n    },\r\n\r\n    template: `\r\n<SlidingDateRangePicker v-if=\"isComparisonTypeBetween\" v-model=\"rangeValue\" />\r\n<EditComponent v-else v-model=\"dateValue\" :configurationValues=\"configurationValues\" />\r\n`\r\n});\r\n\r\nconst defaults = {\r\n    [ConfigurationValueKey.Format]: \"\",\r\n    [ConfigurationValueKey.DisplayAsElapsedTime]: \"False\",\r\n    [ConfigurationValueKey.DisplayCurrentOption]: \"False\",\r\n};\r\n\r\nexport const ConfigurationComponent = defineComponent({\r\n    name: \"DateTimeField.Configuration\",\r\n\r\n    components: {\r\n        TextBox,\r\n        CheckBox\r\n    },\r\n\r\n    props: getFieldConfigurationProps(),\r\n\r\n    emits: [\r\n        \"update:modelValue\",\r\n        \"updateConfiguration\",\r\n        \"updateConfigurationValue\"\r\n    ],\r\n\r\n    setup(props, { emit }) {\r\n        // Define the properties that will hold the current selections.\r\n        const format = ref(\"\");\r\n        const displayAsElapsedTime = ref(false);\r\n        const displayCurrentOption = ref(false);\r\n\r\n        /**\r\n         * Update the modelValue property if any value of the dictionary has\r\n         * actually changed. This helps prevent unwanted postbacks if the value\r\n         * didn't really change - which can happen if multiple values get updated\r\n         * at the same time.\r\n         *\r\n         * @returns true if a new modelValue was emitted to the parent component.\r\n         */\r\n        const maybeUpdateModelValue = (): boolean => {\r\n            const newValue: Record<string, string> = {};\r\n\r\n            // Construct the new value that will be emitted if it is different\r\n            // than the current value.\r\n            newValue[ConfigurationValueKey.Format] = format.value ?? defaults[ConfigurationValueKey.Format];\r\n            newValue[ConfigurationValueKey.DisplayAsElapsedTime] = asTrueFalseOrNull(displayAsElapsedTime.value) ?? defaults[ConfigurationValueKey.DisplayAsElapsedTime];\r\n            newValue[ConfigurationValueKey.DisplayCurrentOption] = asTrueFalseOrNull(displayCurrentOption.value) ?? defaults[ConfigurationValueKey.DisplayCurrentOption];\r\n\r\n            // Compare the new value and the old value.\r\n            const anyValueChanged = newValue[ConfigurationValueKey.Format] !== (props.modelValue[ConfigurationValueKey.Format] ?? defaults[ConfigurationValueKey.Format])\r\n                || newValue[ConfigurationValueKey.DisplayAsElapsedTime] !== (props.modelValue[ConfigurationValueKey.DisplayAsElapsedTime] ?? defaults[ConfigurationValueKey.DisplayAsElapsedTime])\r\n                || newValue[ConfigurationValueKey.DisplayCurrentOption] !== (props.modelValue[ConfigurationValueKey.DisplayCurrentOption] ?? defaults[ConfigurationValueKey.DisplayCurrentOption]);\r\n\r\n            // If any value changed then emit the new model value.\r\n            if (anyValueChanged) {\r\n                emit(\"update:modelValue\", newValue);\r\n                return true;\r\n            }\r\n            else {\r\n                return false;\r\n            }\r\n        };\r\n\r\n        /**\r\n         * Emits the updateConfigurationValue if the value has actually changed.\r\n         *\r\n         * @param key The key that was possibly modified.\r\n         * @param value The new value.\r\n         */\r\n        const maybeUpdateConfiguration = (key: string, value: string): void => {\r\n            if (maybeUpdateModelValue()) {\r\n                emit(\"updateConfigurationValue\", key, value);\r\n            }\r\n        };\r\n\r\n        // Watch for changes coming in from the parent component and update our\r\n        // data to match the new information.\r\n        watch(() => [props.modelValue, props.configurationProperties], () => {\r\n            format.value = props.modelValue[ConfigurationValueKey.Format] ?? \"\";\r\n            displayAsElapsedTime.value = asBoolean(props.modelValue[ConfigurationValueKey.DisplayAsElapsedTime]);\r\n            displayCurrentOption.value = asBoolean(props.modelValue[ConfigurationValueKey.DisplayCurrentOption]);\r\n        }, {\r\n            immediate: true\r\n        });\r\n\r\n        // Watch for changes in properties that require new configuration\r\n        // properties to be retrieved from the server.\r\n        // THIS IS JUST A PLACEHOLDER FOR COPYING TO NEW FIELDS THAT MIGHT NEED IT.\r\n        // THIS FIELD DOES NOT NEED THIS\r\n        watch([], () => {\r\n            if (maybeUpdateModelValue()) {\r\n                emit(\"updateConfiguration\");\r\n            }\r\n        });\r\n\r\n        // Watch for changes in properties that only require a local UI update.\r\n        watch(format, (val) => maybeUpdateConfiguration(ConfigurationValueKey.Format, val ?? defaults[ConfigurationValueKey.Format]));\r\n        watch(displayAsElapsedTime, (val) => maybeUpdateConfiguration(ConfigurationValueKey.DisplayAsElapsedTime, asTrueFalseOrNull(val) ?? defaults[ConfigurationValueKey.DisplayAsElapsedTime]));\r\n        watch(displayCurrentOption, (val) => maybeUpdateConfiguration(ConfigurationValueKey.DisplayCurrentOption, asTrueFalseOrNull(val) ?? defaults[ConfigurationValueKey.DisplayCurrentOption]));\r\n\r\n        return {\r\n            format,\r\n            displayAsElapsedTime,\r\n            displayCurrentOption,\r\n        };\r\n    },\r\n\r\n    template: `\r\n<div>\r\n    <TextBox v-model=\"format\" label=\"Date Time Format\" help=\"The format string to use for date (default is system short date and time)\" />\r\n    <CheckBox v-model=\"displayAsElapsedTime\" label=\"Display as Elapsed Time\" text=\"Yes\" help=\"Display value as an elapsed time\" />\r\n    <CheckBox v-model=\"displayCurrentOption\" label=\"Display Current Option\" text=\"Yes\" help=\"Include option to specify value as the current time\" />\r\n</div>\r\n`\r\n});\r\n"],"names":["ConfigurationValueKey","defineAsyncComponent","_asyncToGenerator","EditComponent","ConfigurationComponent","FilterComponent","defineComponent","name","components","DateTimePicker","props","getFieldEditorProps","setup","data","internalValue","formattedString","methods","syncModelValue","_this","_this$modelValue","modelValue","computed","dateFormatTemplate","formatConfig","configurationValues","Format","configAttributes","attributes","displayCurrentConfig","DisplayCurrentOption","displayCurrent","asBoolean","displayCurrentOption","isCurrentDateOffset","watch","_this$modelValue2","d1","Date","parse","d2","isNaN","$emit","immediate","handler","_this2","template","SlidingDateRangePicker","_objectSpread","comparisonType","type","Number","required","emits","_ref","emit","ref","internalValueSegments","value","split","dateValue","rangeValue","parseSlidingDateRangeString","length","isComparisonTypeBetween","ComparisonType","Between","concat","slidingDateRangeToString","segments","updateRefValue","defaults","DisplayAsElapsedTime","TextBox","CheckBox","getFieldConfigurationProps","_ref2","format","displayAsElapsedTime","maybeUpdateModelValue","_format$value","_asTrueFalseOrNull","_asTrueFalseOrNull2","_props$modelValue$Con","_props$modelValue$Con2","_props$modelValue$Con3","newValue","asTrueFalseOrNull","anyValueChanged","maybeUpdateConfiguration","key","configurationProperties","_props$modelValue$Con4","val","_asTrueFalseOrNull3","_asTrueFalseOrNull4"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;MA4BkBA,IAAAA,qBAAqB,aAArBA,qBAAqB,EAAA;QAArBA,qBAAqB,CAAA,QAAA,CAAA,GAAA,QAAA,CAAA;QAArBA,qBAAqB,CAAA,sBAAA,CAAA,GAAA,aAAA,CAAA;QAArBA,qBAAqB,CAAA,sBAAA,CAAA,GAAA,sBAAA,CAAA;MAAA,EAAA,OAArBA,qBAAqB,CAAA;MAAA,CAAA,CAAA,EAAA,CAAA,CAAA;MAQjBC,oBAAoB,CAAAC,iBAAA,CAAC,aAAY;MACnD,EAAA,OAAO,OAAO,cAAO,2BAA2B,CAAC,EAAEC,aAAa,CAAA;MACpE,CAAC,CAAC,EAAA;MAG6BF,oBAAoB,CAAAC,iBAAA,CAAC,aAAY;MAC5D,EAAA,OAAO,OAAO,cAAO,2BAA2B,CAAC,EAAEE,sBAAsB,CAAA;MAC7E,CAAC,CAAC,EAAA;MAGsBH,oBAAoB,CAAAC,iBAAA,CAAC,aAAY;MACrD,EAAA,OAAO,OAAO,cAAO,2BAA2B,CAAC,EAAEG,eAAe,CAAA;MACtE,CAAC,CAAC;;ACpBWF,UAAAA,aAAa,4BAAGG,eAAe,CAAC;MACzCC,EAAAA,IAAI,EAAE,oBAAoB;MAE1BC,EAAAA,UAAU,EAAE;MACRC,IAAAA,cAAAA;SACH;QAEDC,KAAK,EAAEC,mBAAmB,EAAE;MAE5BC,EAAAA,KAAKA,GAAG;MACJ,IAAA,OAAO,EACN,CAAA;SACJ;MAEDC,EAAAA,IAAIA,GAAG;UACH,OAAO;MACHC,MAAAA,aAAa,EAAE,EAAE;MACjBC,MAAAA,eAAe,EAAE,EAAA;WACpB,CAAA;SACJ;MAEDC,EAAAA,OAAO,EAAE;MACCC,IAAAA,cAAcA,GAAkB;MAAA,MAAA,IAAAC,KAAA,GAAA,IAAA,CAAA;MAAA,MAAA,OAAAhB,iBAAA,CAAA,aAAA;MAAA,QAAA,IAAAiB,gBAAA,CAAA;MAClCD,QAAAA,KAAI,CAACJ,aAAa,GAAAK,CAAAA,gBAAA,GAAGD,KAAI,CAACE,UAAU,MAAAD,IAAAA,IAAAA,gBAAA,KAAAA,KAAAA,CAAAA,GAAAA,gBAAA,GAAI,EAAE,CAAA;MAAC,OAAA,CAAA,EAAA,CAAA;MAC/C,KAAA;SACH;MAEDE,EAAAA,QAAQ,EAAE;MACNC,IAAAA,kBAAkBA,GAAW;YACzB,IAAMC,YAAY,GAAG,IAAI,CAACC,mBAAmB,CAACxB,qBAAqB,CAACyB,MAAM,CAAC,CAAA;YAC3E,OAAOF,YAAY,IAAI,YAAY,CAAA;WACtC;MAEDG,IAAAA,gBAAgBA,GAAqC;YACjD,IAAMC,UAA4C,GAAG,EAAE,CAAA;YAEvD,IAAMC,oBAAoB,GAAG,IAAI,CAACJ,mBAAmB,CAACxB,qBAAqB,CAAC6B,oBAAoB,CAAC,CAAA;MACjG,MAAA,IAAMC,cAAc,GAAGC,SAAS,CAACH,oBAAoB,CAAC,CAAA;YACtDD,UAAU,CAACK,oBAAoB,GAAGF,cAAc,CAAA;YAChDH,UAAU,CAACM,mBAAmB,GAAGH,cAAc,CAAA;MAE/C,MAAA,OAAOH,UAAU,CAAA;MACrB,KAAA;SACH;MAEDO,EAAAA,KAAK,EAAE;MACHpB,IAAAA,aAAaA,GAAS;MAClB,MAAA,IAAI,IAAI,CAACA,aAAa,KAAK,IAAI,CAACM,UAAU,EAAE;MAAA,QAAA,IAAAe,iBAAA,CAAA;cACxC,IAAMC,EAAE,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACxB,aAAa,CAAC,CAAA;MACzC,QAAA,IAAMyB,EAAE,GAAGF,IAAI,CAACC,KAAK,EAAAH,iBAAA,GAAC,IAAI,CAACf,UAAU,MAAAe,IAAAA,IAAAA,iBAAA,cAAAA,iBAAA,GAAI,EAAE,CAAC,CAAA;MAE5C,QAAA,IAAIK,KAAK,CAACJ,EAAE,CAAC,IAAII,KAAK,CAACD,EAAE,CAAC,IAAIH,EAAE,KAAKG,EAAE,EAAE;gBACrC,IAAI,CAACE,KAAK,CAAC,mBAAmB,EAAE,IAAI,CAAC3B,aAAa,CAAC,CAAA;MACvD,SAAA;MACJ,OAAA;WACH;MAEDM,IAAAA,UAAU,EAAE;MACRsB,MAAAA,SAAS,EAAE,IAAI;MACTC,MAAAA,OAAOA,GAAkB;MAAA,QAAA,IAAAC,MAAA,GAAA,IAAA,CAAA;MAAA,QAAA,OAAA1C,iBAAA,CAAA,aAAA;gBAC3B,MAAM0C,MAAI,CAAC3B,cAAc,EAAE,CAAA;MAAC,SAAA,CAAA,EAAA,CAAA;MAChC,OAAA;MACJ,KAAA;SACH;QACD4B,QAAQ,EAAA,8EAAA;MAGZ,CAAC,GAAC;AAEWxC,UAAAA,eAAe,8BAAGC,eAAe,CAAC;MAC3CC,EAAAA,IAAI,EAAE,kBAAkB;MAExBC,EAAAA,UAAU,EAAE;UACRL,aAAa;MACb2C,IAAAA,sBAAAA;SACH;MAEDpC,EAAAA,KAAK,EAAAqC,cAAA,CAAAA,cAAA,CAAA,EAAA,EACEpC,mBAAmB,EAAE,CAAA,EAAA,EAAA,EAAA;MACxBqC,IAAAA,cAAc,EAAE;MACZC,MAAAA,IAAI,EAAEC,MAAyC;MAC/CC,MAAAA,QAAQ,EAAE,IAAA;MACd,KAAA;SACH,CAAA;QAEDC,KAAK,EAAE,CACH,mBAAmB,CACtB;MAEDxC,EAAAA,KAAKA,CAACF,KAAK,EAAA2C,IAAA,EAAY;MAAA,IAAA,IAARC,IAAI,GAAAD,IAAA,CAAJC,IAAI,CAAA;MAEf,IAAA,IAAMxC,aAAa,GAAGyC,GAAG,CAAC7C,KAAK,CAACU,UAAU,CAAC,CAAA;UAC3C,IAAMoC,qBAAqB,GAAG1C,aAAa,CAAC2C,KAAK,CAACC,KAAK,CAAC,IAAI,CAAC,CAAA;UAC7D,IAAMC,SAAS,GAAGJ,GAAG,CAACC,qBAAqB,CAAC,CAAC,CAAC,CAAC,CAAA;MAC/C,IAAA,IAAMI,UAAU,GAAGL,GAAG,CAACM,2BAA2B,CAACL,qBAAqB,CAACM,MAAM,GAAG,CAAC,GAAGN,qBAAqB,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;UAGrH,IAAMhC,mBAAmB,GAAG+B,GAAG,CAAAR,cAAA,CAAMrC,EAAAA,EAAAA,KAAK,CAACc,mBAAmB,CAAG,CAAA,CAAA;UACjEA,mBAAmB,CAACiC,KAAK,CAACzD,qBAAqB,CAAC6B,oBAAoB,CAAC,GAAG,MAAM,CAAA;MAG9E,IAAA,IAAMkC,uBAAuB,GAAG1C,QAAQ,CAAC,MAAeX,KAAK,CAACsC,cAAc,KAAKgB,cAAc,CAACC,OAAO,CAAC,CAAA;MAGxG/B,IAAAA,KAAK,CAAC,MAAMxB,KAAK,CAACc,mBAAmB,EAAE,MAAM;YACzCA,mBAAmB,CAACiC,KAAK,GAAAV,cAAA,KAAQrC,KAAK,CAACc,mBAAmB,CAAE,CAAA;YAC5DA,mBAAmB,CAACiC,KAAK,CAACzD,qBAAqB,CAAC6B,oBAAoB,CAAC,GAAG,MAAM,CAAA;MAClF,KAAC,CAAC,CAAA;UAGFK,KAAK,CAACyB,SAAS,EAAE,MAAM;MACnB,MAAA,IAAIjD,KAAK,CAACsC,cAAc,KAAKgB,cAAc,CAACC,OAAO,EAAE;cACjDnD,aAAa,CAAC2C,KAAK,GAAAS,EAAAA,CAAAA,MAAA,CAAMP,SAAS,CAACF,KAAK,EAAI,IAAA,CAAA,CAAA;MAChD,OAAA;MACJ,KAAC,CAAC,CAAA;UAGFvB,KAAK,CAAC0B,UAAU,EAAE,MAAM;MACpB,MAAA,IAAIlD,KAAK,CAACsC,cAAc,KAAKgB,cAAc,CAACC,OAAO,EAAE;MACjDnD,QAAAA,aAAa,CAAC2C,KAAK,GAAA,IAAA,CAAAS,MAAA,CAAQN,UAAU,CAACH,KAAK,GAAGU,wBAAwB,CAACP,UAAU,CAACH,KAAK,CAAC,GAAG,EAAE,CAAE,CAAA;MACnG,OAAA;MACJ,KAAC,CAAC,CAAA;MAGFvB,IAAAA,KAAK,CAAC,MAAMxB,KAAK,CAACU,UAAU,EAAE,MAAM;MAChCN,MAAAA,aAAa,CAAC2C,KAAK,GAAG/C,KAAK,CAACU,UAAU,CAAA;YACtC,IAAMgD,QAAQ,GAAGtD,aAAa,CAAC2C,KAAK,CAACC,KAAK,CAAC,IAAI,CAAC,CAAA;MAChDC,MAAAA,SAAS,CAACF,KAAK,GAAGW,QAAQ,CAAC,CAAC,CAAC,CAAA;MAC7BC,MAAAA,cAAc,CAACT,UAAU,EAAEC,2BAA2B,CAACO,QAAQ,CAACN,MAAM,GAAG,CAAC,GAAGM,QAAQ,CAAC,CAAC,CAAC,GAAG,EAAE,CAAC,CAAC,CAAA;MACnG,KAAC,CAAC,CAAA;UAGFlC,KAAK,CAACpB,aAAa,EAAE,MAAM;MACvBwC,MAAAA,IAAI,CAAC,mBAAmB,EAAExC,aAAa,CAAC2C,KAAK,CAAC,CAAA;MAClD,KAAC,CAAC,CAAA;UAEF,OAAO;YACHjC,mBAAmB;YACnBmC,SAAS;YACTI,uBAAuB;MACvBH,MAAAA,UAAAA;WACH,CAAA;SACJ;QAEDf,QAAQ,EAAA,qLAAA;MAIZ,CAAC,GAAC;MAEF,IAAMyB,QAAQ,GAAG;MACb,EAAA,CAACtE,qBAAqB,CAACyB,MAAM,GAAG,EAAE;MAClC,EAAA,CAACzB,qBAAqB,CAACuE,oBAAoB,GAAG,OAAO;QACrD,CAACvE,qBAAqB,CAAC6B,oBAAoB,GAAG,OAAA;MAClD,CAAC,CAAA;AAEYzB,UAAAA,sBAAsB,qCAAGE,eAAe,CAAC;MAClDC,EAAAA,IAAI,EAAE,6BAA6B;MAEnCC,EAAAA,UAAU,EAAE;UACRgE,OAAO;MACPC,IAAAA,QAAAA;SACH;QAED/D,KAAK,EAAEgE,0BAA0B,EAAE;MAEnCtB,EAAAA,KAAK,EAAE,CACH,mBAAmB,EACnB,qBAAqB,EACrB,0BAA0B,CAC7B;MAEDxC,EAAAA,KAAKA,CAACF,KAAK,EAAAiE,KAAA,EAAY;MAAA,IAAA,IAARrB,IAAI,GAAAqB,KAAA,CAAJrB,IAAI,CAAA;MAEf,IAAA,IAAMsB,MAAM,GAAGrB,GAAG,CAAC,EAAE,CAAC,CAAA;MACtB,IAAA,IAAMsB,oBAAoB,GAAGtB,GAAG,CAAC,KAAK,CAAC,CAAA;MACvC,IAAA,IAAMvB,oBAAoB,GAAGuB,GAAG,CAAC,KAAK,CAAC,CAAA;UAUvC,IAAMuB,qBAAqB,GAAGA,MAAe;YAAA,IAAAC,aAAA,EAAAC,kBAAA,EAAAC,mBAAA,EAAAC,qBAAA,EAAAC,sBAAA,EAAAC,sBAAA,CAAA;YACzC,IAAMC,QAAgC,GAAG,EAAE,CAAA;YAI3CA,QAAQ,CAACrF,qBAAqB,CAACyB,MAAM,CAAC,GAAAsD,CAAAA,aAAA,GAAGH,MAAM,CAACnB,KAAK,MAAAsB,IAAAA,IAAAA,aAAA,cAAAA,aAAA,GAAIT,QAAQ,CAACtE,qBAAqB,CAACyB,MAAM,CAAC,CAAA;YAC/F4D,QAAQ,CAACrF,qBAAqB,CAACuE,oBAAoB,CAAC,IAAAS,kBAAA,GAAGM,iBAAiB,CAACT,oBAAoB,CAACpB,KAAK,CAAC,MAAA,IAAA,IAAAuB,kBAAA,KAAA,KAAA,CAAA,GAAAA,kBAAA,GAAIV,QAAQ,CAACtE,qBAAqB,CAACuE,oBAAoB,CAAC,CAAA;YAC5Jc,QAAQ,CAACrF,qBAAqB,CAAC6B,oBAAoB,CAAC,IAAAoD,mBAAA,GAAGK,iBAAiB,CAACtD,oBAAoB,CAACyB,KAAK,CAAC,MAAA,IAAA,IAAAwB,mBAAA,KAAA,KAAA,CAAA,GAAAA,mBAAA,GAAIX,QAAQ,CAACtE,qBAAqB,CAAC6B,oBAAoB,CAAC,CAAA;MAG5J,MAAA,IAAM0D,eAAe,GAAGF,QAAQ,CAACrF,qBAAqB,CAACyB,MAAM,CAAC,MAAA,CAAAyD,qBAAA,GAAMxE,KAAK,CAACU,UAAU,CAACpB,qBAAqB,CAACyB,MAAM,CAAC,MAAAyD,IAAAA,IAAAA,qBAAA,cAAAA,qBAAA,GAAIZ,QAAQ,CAACtE,qBAAqB,CAACyB,MAAM,CAAC,CAAC,IACtJ4D,QAAQ,CAACrF,qBAAqB,CAACuE,oBAAoB,CAAC,MAAA,CAAAY,sBAAA,GAAMzE,KAAK,CAACU,UAAU,CAACpB,qBAAqB,CAACuE,oBAAoB,CAAC,MAAA,IAAA,IAAAY,sBAAA,KAAAA,KAAAA,CAAAA,GAAAA,sBAAA,GAAIb,QAAQ,CAACtE,qBAAqB,CAACuE,oBAAoB,CAAC,CAAC,IAC/Kc,QAAQ,CAACrF,qBAAqB,CAAC6B,oBAAoB,CAAC,OAAAuD,sBAAA,GAAM1E,KAAK,CAACU,UAAU,CAACpB,qBAAqB,CAAC6B,oBAAoB,CAAC,MAAA,IAAA,IAAAuD,sBAAA,KAAAA,KAAAA,CAAAA,GAAAA,sBAAA,GAAId,QAAQ,CAACtE,qBAAqB,CAAC6B,oBAAoB,CAAC,CAAC,CAAA;MAGtL,MAAA,IAAI0D,eAAe,EAAE;MACjBjC,QAAAA,IAAI,CAAC,mBAAmB,EAAE+B,QAAQ,CAAC,CAAA;MACnC,QAAA,OAAO,IAAI,CAAA;MACf,OAAC,MACI;MACD,QAAA,OAAO,KAAK,CAAA;MAChB,OAAA;WACH,CAAA;MAQD,IAAA,IAAMG,wBAAwB,GAAGA,CAACC,GAAW,EAAEhC,KAAa,KAAW;YACnE,IAAIqB,qBAAqB,EAAE,EAAE;MACzBxB,QAAAA,IAAI,CAAC,0BAA0B,EAAEmC,GAAG,EAAEhC,KAAK,CAAC,CAAA;MAChD,OAAA;WACH,CAAA;MAIDvB,IAAAA,KAAK,CAAC,MAAM,CAACxB,KAAK,CAACU,UAAU,EAAEV,KAAK,CAACgF,uBAAuB,CAAC,EAAE,MAAM;MAAA,MAAA,IAAAC,sBAAA,CAAA;MACjEf,MAAAA,MAAM,CAACnB,KAAK,GAAA,CAAAkC,sBAAA,GAAGjF,KAAK,CAACU,UAAU,CAACpB,qBAAqB,CAACyB,MAAM,CAAC,MAAA,IAAA,IAAAkE,sBAAA,KAAAA,KAAAA,CAAAA,GAAAA,sBAAA,GAAI,EAAE,CAAA;MACnEd,MAAAA,oBAAoB,CAACpB,KAAK,GAAG1B,SAAS,CAACrB,KAAK,CAACU,UAAU,CAACpB,qBAAqB,CAACuE,oBAAoB,CAAC,CAAC,CAAA;MACpGvC,MAAAA,oBAAoB,CAACyB,KAAK,GAAG1B,SAAS,CAACrB,KAAK,CAACU,UAAU,CAACpB,qBAAqB,CAAC6B,oBAAoB,CAAC,CAAC,CAAA;MACxG,KAAC,EAAE;MACCa,MAAAA,SAAS,EAAE,IAAA;MACf,KAAC,CAAC,CAAA;UAMFR,KAAK,CAAC,EAAE,EAAE,MAAM;YACZ,IAAI4C,qBAAqB,EAAE,EAAE;cACzBxB,IAAI,CAAC,qBAAqB,CAAC,CAAA;MAC/B,OAAA;MACJ,KAAC,CAAC,CAAA;UAGFpB,KAAK,CAAC0C,MAAM,EAAGgB,GAAG,IAAKJ,wBAAwB,CAACxF,qBAAqB,CAACyB,MAAM,EAAEmE,GAAG,aAAHA,GAAG,KAAA,KAAA,CAAA,GAAHA,GAAG,GAAItB,QAAQ,CAACtE,qBAAqB,CAACyB,MAAM,CAAC,CAAC,CAAC,CAAA;UAC7HS,KAAK,CAAC2C,oBAAoB,EAAGe,GAAG,IAAA;MAAA,MAAA,IAAAC,mBAAA,CAAA;YAAA,OAAKL,wBAAwB,CAACxF,qBAAqB,CAACuE,oBAAoB,EAAAsB,CAAAA,mBAAA,GAAEP,iBAAiB,CAACM,GAAG,CAAC,MAAAC,IAAAA,IAAAA,mBAAA,KAAAA,KAAAA,CAAAA,GAAAA,mBAAA,GAAIvB,QAAQ,CAACtE,qBAAqB,CAACuE,oBAAoB,CAAC,CAAC,CAAA;WAAC,CAAA,CAAA;UAC1LrC,KAAK,CAACF,oBAAoB,EAAG4D,GAAG,IAAA;MAAA,MAAA,IAAAE,mBAAA,CAAA;YAAA,OAAKN,wBAAwB,CAACxF,qBAAqB,CAAC6B,oBAAoB,EAAAiE,CAAAA,mBAAA,GAAER,iBAAiB,CAACM,GAAG,CAAC,MAAAE,IAAAA,IAAAA,mBAAA,KAAAA,KAAAA,CAAAA,GAAAA,mBAAA,GAAIxB,QAAQ,CAACtE,qBAAqB,CAAC6B,oBAAoB,CAAC,CAAC,CAAA;WAAC,CAAA,CAAA;UAE1L,OAAO;YACH+C,MAAM;YACNC,oBAAoB;MACpB7C,MAAAA,oBAAAA;WACH,CAAA;SACJ;QAEDa,QAAQ,EAAA,+cAAA;MAOZ,CAAC;;;;;;;;"}