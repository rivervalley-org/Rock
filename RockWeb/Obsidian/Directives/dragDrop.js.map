{"version":3,"file":"dragDrop.js","sources":["../../../Framework/Directives/dragDrop.ts"],"sourcesContent":["// <copyright>\r\n// Copyright by the Spark Development Network\r\n//\r\n// Licensed under the Rock Community License (the \"License\");\r\n// you may not use this file except in compliance with the License.\r\n// You may obtain a copy of the License at\r\n//\r\n// http://www.rockrms.com/license\r\n//\r\n// Unless required by applicable law or agreed to in writing, software\r\n// distributed under the License is distributed on an \"AS IS\" BASIS,\r\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\n// See the License for the specific language governing permissions and\r\n// limitations under the License.\r\n// </copyright>\r\n//\r\n\r\nimport { Directive, Ref } from \"vue\";\r\nimport { loadJavaScriptAsync } from \"@Obsidian/Utility/page\";\r\nimport { newGuid } from \"@Obsidian/Utility/guid\";\r\n\r\nconst dragulaScriptPromise = loadJavaScriptAsync(\"/Scripts/dragula.min.js\", () => window.dragula !== undefined);\r\n\r\n/**\r\n * The options that can be used when defining a drag source for a drag and\r\n * drop operation.\r\n */\r\nexport interface IDragSourceOptions {\r\n    /**\r\n     * The unique identifier for this drag drop connection. This should match\r\n     * the id used for drag targets.\r\n     */\r\n    id: string;\r\n\r\n    /**\r\n     * Defines the query selector that specifies which elements may act as drag\r\n     * handles. By default all elements are allowed. This value will be ignored\r\n     * if you defined a value for canStartDrag.\r\n     */\r\n    handleSelector?: string;\r\n\r\n    /**\r\n     * Defines the container element that dragged mirror elements will be added\r\n     * to. If not set then the body element is used. This property is dynamic and\r\n     * can be updated on the fly. It will be used anytime a drag operation is\r\n     * about to begin.\r\n     */\r\n    mirrorContainer?: Element;\r\n\r\n    /**\r\n     * true if elements are duplicated and instead of the original being moved.\r\n     */\r\n    copyElement?: boolean | ((operation: DragOperation) => boolean);\r\n\r\n    /**\r\n     * Function that returns true if the element can start dragging.\r\n     */\r\n    startDrag?: (operation: DragOperation, handle: Element) => boolean;\r\n\r\n    /**\r\n     * Function that returns true if the element being dragged can be dropped\r\n     * on the target.\r\n     */\r\n    acceptDrop?: (operation: DragOperation) => boolean;\r\n\r\n    /**\r\n     * Called when a drag operation has successfully started. \r\n     */\r\n    dragBegin?: (operation: DragOperation) => void;\r\n\r\n    /**\r\n     * Called when a drag operation has ended for any reason. \r\n     */\r\n    dragEnd?: (operation: DragOperation) => void;\r\n\r\n    /**\r\n     * Called when a drag operation has successfully completed.\r\n     */\r\n    dragDrop?: (operation: DragOperation) => void;\r\n\r\n    /**\r\n     * Called when the drag operation was cancelled, usually because it was dropped\r\n     * outside of a valid container.\r\n     */\r\n    dragCancel?: (operation: DragOperation) => void;\r\n\r\n    /**\r\n     * Called when a drag operation has moved over the specified valid target\r\n     * container.\r\n     */\r\n    dragOver?: (operation: DragOperation) => void;\r\n\r\n    /**\r\n     * Called when a drag operation has moved out of the specified container (or\r\n     * was dropped into it).\r\n     */\r\n    dragOut?: (operation: DragOperation) => void;\r\n\r\n    /**\r\n     * Called when a drag operation has created, or positioned, the shadow element\r\n     * that is being displayed in the target container.\r\n     */\r\n    dragShadow?: (operation: DragOperation) => void;\r\n}\r\n\r\n/**\r\n * The options that can be used when defining a drag target for a drag and\r\n * drop operation.\r\n */\r\nexport interface IDragTargetOptions {\r\n    id: string;\r\n}\r\n\r\n/**\r\n * Allows for an association between an element and the options it was\r\n * initialized with.\r\n */\r\ntype ElementOptions<T> = {\r\n    /** The element associated with the options. */\r\n    element: Element;\r\n\r\n    /** The options associated with the element. */\r\n    options: T;\r\n};\r\n\r\n/**\r\n * Details about a drag operation that is in progress.\r\n */\r\nexport type DragOperation = {\r\n    /** The element that is being dragged. */\r\n    element: Element;\r\n\r\n    /** The shadow element that is currently displayed in the target container. */\r\n    shadow?: Element;\r\n\r\n    /** The container that the element is originally from. */\r\n    sourceContainer: Element;\r\n\r\n    /** The index position in the sourceContainer for the element. */\r\n    sourceIndex: number;\r\n\r\n    /** The next sibling after the element before the drag operation started. */\r\n    sourceSibling?: Element;\r\n\r\n    /** The target container the element is hovering over or being dropped into. */\r\n    targetContainer?: Element;\r\n\r\n    /** The index position in the targetContainer. */\r\n    targetIndex?: number;\r\n\r\n    /** The next sibling the element is hovering or being dropped before. */\r\n    targetSibling?: Element;\r\n};\r\n\r\n/**\r\n * Service to handle drag and drop operations between two containers. The\r\n * service describes the path for the drag and drop operation. Each service\r\n * can have multiple source containers and multiple target containers. A\r\n * source container should only ever associated with a single service but\r\n * a target container can be associated with multiple services.\r\n */\r\nclass DragDropService {\r\n    /** The unique identifier of this service path. Recommended as a Guid. */\r\n    public readonly id: string;\r\n\r\n    /** The underlying drake object that will handle the drag and drop feature. */\r\n    private drake: dragula.Drake;\r\n\r\n    /** The source containers and their initialization options. */\r\n    private sourceContainers: ElementOptions<IDragSourceOptions>[] = [];\r\n\r\n    /** The target containers and their initialization options. */\r\n    private targetContainers: ElementOptions<IDragTargetOptions>[] = [];\r\n\r\n    /** The internal drag operation that is currently in progress. */\r\n    private internalOperation?: DragOperation;\r\n\r\n    private options: dragula.DragulaOptions;\r\n\r\n    /**\r\n     * Creates a new instance of the DragDropService class.\r\n     * \r\n     * @param identifier The unique identifier of this service.\r\n     */\r\n    constructor(identifier: string) {\r\n        this.id = identifier;\r\n        this.options = {\r\n            accepts: this.drakeAccepts.bind(this),\r\n            copy: this.drakeCopy.bind(this),\r\n            moves: this.drakeMoves.bind(this),\r\n            revertOnSpill: true\r\n        };\r\n\r\n        this.drake = window.dragula([], this.options);\r\n\r\n        this.drake.on(\"drag\", this.drakeEventDrag.bind(this));\r\n        this.drake.on(\"drop\", this.drakeEventDrop.bind(this));\r\n        this.drake.on(\"over\", this.drakeEventOver.bind(this));\r\n        this.drake.on(\"out\", this.drakeEventOut.bind(this));\r\n        this.drake.on(\"cancel\", this.drakeEventCancel.bind(this));\r\n        this.drake.on(\"dragend\", this.drakeEventEnd.bind(this));\r\n        this.drake.on(\"shadow\", this.drakeEventShadow.bind(this));\r\n    }\r\n\r\n    /**\r\n     * Checks if this service is considered finished and can be destroyed.\r\n     *\r\n     * @returns true if this service is finished and has no reason to live.\r\n     */\r\n    public isFinished(): boolean {\r\n        return this.sourceContainers.length === 0 && this.targetContainers.length === 0;\r\n    }\r\n\r\n    /**\r\n     * Destroys the service and prepares everything for disposal.\r\n     */\r\n    public destroy(): void {\r\n        this.drake.destroy();\r\n    }\r\n\r\n    /**\r\n     * Adds a new source container to the service.\r\n     *\r\n     * @param container The container that will begin drags.\r\n     * @param options Additional options that provide operational context to the source.\r\n     */\r\n    public addSourceContainer(container: Element, options: IDragSourceOptions): void {\r\n        const containerIndex = this.sourceContainers.findIndex(c => c.element === container);\r\n\r\n        if (containerIndex === -1) {\r\n            this.sourceContainers.push({\r\n                element: container,\r\n                options: options\r\n            });\r\n        }\r\n\r\n        this.updateDrakeContainers();\r\n    }\r\n\r\n    /**\r\n     * Adds a new target container to the service.\r\n     * \r\n     * @param container The container that will accept drops.\r\n     * @param options Additional options that provide operational context to the target.\r\n     */\r\n    public addTargetContainer(container: Element, options: IDragTargetOptions): void {\r\n        const containerIndex = this.targetContainers.findIndex(c => c.element === container);\r\n\r\n        if (containerIndex === -1) {\r\n            this.targetContainers.push({\r\n                element: container,\r\n                options: options\r\n            });\r\n        }\r\n\r\n        this.updateDrakeContainers();\r\n    }\r\n\r\n    /**\r\n     * Remove a source container that will no longer begin drag operations.\r\n     * \r\n     * @param container The container that will be removed.\r\n     */\r\n    public removeSourceContainer(container: Element): void {\r\n        const containerIndex = this.sourceContainers.findIndex(c => c.element === container);\r\n\r\n        if (containerIndex !== -1) {\r\n            this.sourceContainers.splice(containerIndex, 1);\r\n        }\r\n\r\n        this.updateDrakeContainers();\r\n    }\r\n\r\n    /**\r\n     * Remove a target container that will no longer accept drop operations.\r\n     * \r\n     * @param container The container that will be removed.\r\n     */\r\n    public removeTargetContainer(container: Element): void {\r\n        const containerIndex = this.targetContainers.findIndex(c => c.element === container);\r\n\r\n        if (containerIndex !== -1) {\r\n            this.targetContainers.splice(containerIndex, 1);\r\n        }\r\n\r\n        this.updateDrakeContainers();\r\n    }\r\n\r\n    /**\r\n     * Updates the containers on the drake object with the current list of\r\n     * containers from both the source and target lists.\r\n     */\r\n    private updateDrakeContainers(): void {\r\n        this.drake.containers = this.sourceContainers.map(c => c.element)\r\n            .concat(...this.targetContainers.map(c => c.element));\r\n    }\r\n\r\n    // #region Dragula Event Handlers\r\n\r\n    /**\r\n     * Determines if an element should be copied or moved. This is called\r\n     * after dragula has decided the element can be dragged but before the drag\r\n     * event is triggered.\r\n     * \r\n     * @param el The element that is about to be dragged.\r\n     * @param container The container that contains the element.\r\n     *\r\n     * @returns true if the element should be copied; otherwise false.\r\n     */\r\n    private drakeCopy(el: Element, container: Element): boolean {\r\n        const elementOptions = this.sourceContainers.find(c => c.element === container);\r\n\r\n        // Check if the user has a custom copyElement handler.\r\n        if (elementOptions?.options.copyElement !== undefined) {\r\n            if (typeof elementOptions.options.copyElement === \"function\") {\r\n                const sourceIndex = Array.from(container.children).indexOf(el);\r\n\r\n                return elementOptions.options.copyElement({\r\n                    element: el,\r\n                    sourceContainer: container,\r\n                    sourceIndex: sourceIndex,\r\n                    sourceSibling: el.nextElementSibling ?? undefined\r\n                });\r\n            }\r\n            else {\r\n                return elementOptions.options.copyElement;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determines if an element is allowed to be dragged.\r\n     * \r\n     * @param el The element that would be moved or copied out of the container.\r\n     * @param container The source container for the operation.\r\n     * @param handle The element the user is currently interacting with.\r\n     * @param sibling The next sibling to the element that will be dragged.\r\n     */\r\n    private drakeMoves(el?: Element, container?: Element, handle?: Element, sibling?: Element | null): boolean {\r\n        if (!el || !container || !handle) {\r\n            return false;\r\n        }\r\n\r\n        const elementOptions = this.sourceContainers.find(c => c.element === container);\r\n\r\n        // No options found means this isn't a source container.\r\n        if (!elementOptions) {\r\n            return false;\r\n        }\r\n\r\n        this.options.mirrorContainer = elementOptions.options.mirrorContainer || container;\r\n\r\n        // User has defined their own custom logic to determine if a drag\r\n        // operation can begin.\r\n        if (elementOptions.options.startDrag) {\r\n            const sourceIndex = Array.from(container.children).indexOf(el);\r\n\r\n            return elementOptions.options.startDrag({\r\n                element: el,\r\n                sourceContainer: container,\r\n                sourceIndex,\r\n                sourceSibling: sibling ?? undefined\r\n            }, handle);\r\n        }\r\n\r\n        // No canStartDrag defined. Use default behavior. Check if they defined\r\n        // a handleSelector value and use that to see if the handle is valid.\r\n        // If the handle selector matches the handle exactly or the handle\r\n        // is a descendant of any element matching handle selector, then drag.\r\n        if (elementOptions.options.handleSelector) {\r\n            return Array.from(container.querySelectorAll(elementOptions.options.handleSelector))\r\n                .some(n => n.contains(handle));\r\n        }\r\n\r\n        // Default is to always allow drag.\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Checks if the target container will accept the element as a drop.\r\n     * \r\n     * @param el The element being dragged.\r\n     * @param target The target container being considered for the drop operation.\r\n     * @param source The source container the element came from.\r\n     * @param sibling The next sibling of the element in the target container.\r\n     *\r\n     * @returns true if the element will be accepted into the target.\r\n     */\r\n    private drakeAccepts(el?: Element, target?: Element, source?: Element, sibling?: Element | null): boolean {\r\n        if (!el || !source || !target) {\r\n            return false;\r\n        }\r\n\r\n        const sourceOptions = this.sourceContainers.find(c => c.element === source);\r\n        const targetOptions = this.targetContainers.find(c => c.element === target);\r\n\r\n        // No sourceOptions found means this isn't a valid source container.\r\n        // No targetOptions found means this isn't a valid target container.\r\n        if (!sourceOptions || !targetOptions || !this.internalOperation) {\r\n            return false;\r\n        }\r\n\r\n        // Dragula sometimes returns the shadow object being placed and\r\n        // sometimes the sibling. Make sure we get a real sibling.\r\n        const realSibling = sibling && sibling.classList.contains(\"gu-transit\") ? sibling.nextElementSibling : sibling;\r\n        const targetIndex = realSibling ? Array.from(target.children).indexOf(realSibling) - 1 : target.children.length - 1;\r\n\r\n        // Give the parent container a chance to decide if the drop is valid.\r\n        if (sourceOptions.options.acceptDrop !== undefined) {\r\n            return sourceOptions.options.acceptDrop({\r\n                ...this.internalOperation,\r\n                targetContainer: target,\r\n                targetIndex,\r\n                targetSibling: realSibling ?? undefined\r\n            });\r\n        }\r\n\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Notification that a drag operation has begun.\r\n     * \r\n     * @param el The element that is now being dragged by the user.\r\n     * @param source The source container the element came from.\r\n     */\r\n    private drakeEventDrag(el: Element, source: Element): void {\r\n        const sourceIndex = Array.from(source.children).indexOf(el);\r\n\r\n        this.internalOperation = {\r\n            element: el,\r\n            sourceContainer: source,\r\n            sourceIndex,\r\n            sourceSibling: el.nextElementSibling ?? undefined\r\n        };\r\n\r\n        const sourceOptions = this.sourceContainers.find(c => c.element === source);\r\n\r\n        // No sourceOptions found means this isn't a valid source container.\r\n        if (!sourceOptions) {\r\n            return;\r\n        }\r\n\r\n        if (sourceOptions.options.dragBegin) {\r\n            sourceOptions.options.dragBegin({\r\n                ...this.internalOperation\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Notification that a drag operation has completed and the element dropped\r\n     * into a new container.\r\n     * \r\n     * @param el The element that was dropped.\r\n     * @param target The target container the element was dropped into.\r\n     * @param source The source container the element came from.\r\n     * @param sibling The next sibling of the element in the target container.\r\n     */\r\n    private drakeEventDrop(el: Element, target: Element, source: Element, sibling?: Element | null): void {\r\n        const sourceOptions = this.sourceContainers.find(c => c.element === source);\r\n        const targetOptions = this.targetContainers.find(c => c.element === target);\r\n\r\n        // No sourceOptions found means this isn't a valid source container.\r\n        // No targetOptions found means this isn't a valid target container.\r\n        if (!sourceOptions || !targetOptions || !this.internalOperation) {\r\n            return;\r\n        }\r\n\r\n        const targetIndex = Array.from(target.children).indexOf(el);\r\n\r\n        if (sourceOptions.options.dragDrop) {\r\n            sourceOptions.options.dragDrop({\r\n                ...this.internalOperation,\r\n                element: el,\r\n                targetContainer: target,\r\n                targetIndex,\r\n                targetSibling: sibling ?? undefined\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Notification that the drag operation was cancelled, usually this means\r\n     * the element was dropped outside a valid target container.\r\n     * \r\n     * @param el The element that is no longer being dragged.\r\n     * @param lastContainer The last valid container the element is being returned to.\r\n     * @param source The source container the element came from.\r\n     */\r\n    private drakeEventCancel(el: Element, lastContainer: Element, source: Element): void {\r\n        const sourceOptions = this.sourceContainers.find(c => c.element === source);\r\n\r\n        // No sourceOptions found means this isn't a valid source container.\r\n        if (!sourceOptions || !this.internalOperation) {\r\n            return;\r\n        }\r\n\r\n        if (sourceOptions.options.dragCancel) {\r\n            sourceOptions.options.dragCancel({\r\n                ...this.internalOperation\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Notification that the drag operation is now hovering over a target\r\n     * container. This is only called if true is returned from drakeAccepts.\r\n     * \r\n     * @param el The element that is being dragged.\r\n     * @param target The target container being hovered over.\r\n     * @param source The source container the element came from.\r\n     */\r\n    private drakeEventOver(el: Element, target: Element, source: Element): void {\r\n        const sourceOptions = this.sourceContainers.find(c => c.element === source);\r\n        const targetOptions = this.targetContainers.find(c => c.element === target);\r\n\r\n        // No sourceOptions found means this isn't a valid source container.\r\n        // No targetOptions found means this isn't a valid target container.\r\n        if (!sourceOptions || !targetOptions || !this.internalOperation) {\r\n            return;\r\n        }\r\n\r\n        if (sourceOptions.options.dragOver) {\r\n            sourceOptions.options.dragOver({\r\n                ...this.internalOperation,\r\n                targetContainer: target\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Notification that the drag operation has moved out of the specified\r\n     * target container.\r\n     * \r\n     * @param el The element being dragged.\r\n     * @param target The target container the operation just moved out of.\r\n     * @param source The source container the element came from.\r\n     */\r\n    private drakeEventOut(el: Element, target: Element, source: Element): void {\r\n        const sourceOptions = this.sourceContainers.find(c => c.element === source);\r\n        const targetOptions = this.targetContainers.find(c => c.element === target);\r\n\r\n        // No sourceOptions found means this isn't a valid source container.\r\n        // No targetOptions found means this isn't a valid target container.\r\n        if (!sourceOptions || !targetOptions || !this.internalOperation) {\r\n            return;\r\n        }\r\n\r\n        if (sourceOptions.options.dragOut) {\r\n            sourceOptions.options.dragOut({\r\n                ...this.internalOperation,\r\n                targetContainer: target\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Notification that the drag operation has ended. This is called no matter\r\n     * what reason caused the end.\r\n     * \r\n     * @param el The element that was being dragged.\r\n     */\r\n    private drakeEventEnd(el: Element): void {\r\n        const sourceOptions = this.sourceContainers.find(c => c.element === this.internalOperation?.sourceContainer);\r\n\r\n        // No sourceOptions found means this isn't a valid source container.\r\n        if (!sourceOptions || !this.internalOperation || this.internalOperation.element !== el) {\r\n            return;\r\n        }\r\n\r\n        if (sourceOptions.options.dragEnd) {\r\n            sourceOptions.options.dragEnd({\r\n                ...this.internalOperation\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Notification that the drag operation has created (or moved) a shadow\r\n     * element.\r\n     * \r\n     * @param el The shadow element that is has been added to the container (this is NOT the original element).\r\n     * @param target The target container being hovered over.\r\n     * @param source The source container the element came from.\r\n     */\r\n    private drakeEventShadow(el: Element, target: Element, source: Element): void {\r\n        const sourceOptions = this.sourceContainers.find(c => c.element === source);\r\n        const targetOptions = this.targetContainers.find(c => c.element === target);\r\n\r\n        // No sourceOptions found means this isn't a valid source container.\r\n        // No targetOptions found means this isn't a valid target container.\r\n        if (!sourceOptions || !targetOptions || !this.internalOperation) {\r\n            return;\r\n        }\r\n\r\n        if (sourceOptions.options.dragShadow) {\r\n            sourceOptions.options.dragShadow({\r\n                ...this.internalOperation,\r\n                shadow: el\r\n            });\r\n        }\r\n    }\r\n\r\n    // #endregion\r\n}\r\n\r\n/**\r\n * The known drag and drop services that are currently in use on the page.\r\n */\r\nconst knownServices: Record<string, DragDropService> = {};\r\n\r\n/**\r\n * Gets an existing DragDropService for the given identifier.\r\n * \r\n * @param identifier The identifier of the service to be retrieved.\r\n *\r\n * @returns The DragDropService or undefined if it was not found.\r\n */\r\nfunction getExistingDragDropService(identifier: string): DragDropService | undefined {\r\n    return knownServices[identifier];\r\n}\r\n\r\n/**\r\n * Gets a DragDropService for the given identifier, creating it if necessary.\r\n * \r\n * @param identifier The identifier of the service to be retrieved.\r\n *\r\n * @returns The DragDropService for the identifier.\r\n */\r\nfunction getDragDropService(identifier: string): DragDropService {\r\n    if (knownServices[identifier]) {\r\n        return knownServices[identifier];\r\n    }\r\n\r\n    const service = new DragDropService(identifier);\r\n\r\n    knownServices[identifier] = service;\r\n\r\n    return service;\r\n}\r\n\r\n/**\r\n * Destroys a DragDropService and removes it from the known list of services.\r\n * \r\n * @param service The service to be destroyed.\r\n */\r\nfunction destroyService(service: DragDropService): void {\r\n    service.destroy();\r\n    delete knownServices[service.id];\r\n}\r\n\r\n/**\r\n * Get the target options from the value, which could either be an options\r\n * object or a simple string identifier.\r\n * \r\n * @param value The value that should be translated into an options object.\r\n *\r\n * @returns An options object that conforms to IDragTargetOptions.\r\n */\r\nfunction getTargetOptions(value: string | IDragTargetOptions): IDragTargetOptions | null {\r\n    if (!value) {\r\n        return null;\r\n    }\r\n\r\n    if (typeof value === \"string\") {\r\n        return {\r\n            id: value\r\n        };\r\n    }\r\n    else if (typeof value === \"object\" && value.id) {\r\n        return value;\r\n    }\r\n    else {\r\n        return null;\r\n    }\r\n}\r\n\r\n/**\r\n * Defines the source of a drag and drop operation.\r\n *\r\n * When using a v-for to display the items, ensure you use a unique :key. Otherwise\r\n * when you .splice() after a drop weird things will happen.\r\n */\r\nexport const DragSource: Directive<HTMLElement, IDragSourceOptions> = {\r\n    mounted(element, binding) {\r\n        if (!binding.value || !binding.value.id) {\r\n            console.error(\"DragSource must have a valid identifier.\");\r\n            return;\r\n        }\r\n\r\n        dragulaScriptPromise.then(() => {\r\n            const service = getDragDropService(binding.value.id);\r\n\r\n            service.addSourceContainer(element, binding.value);\r\n        });\r\n    },\r\n\r\n    unmounted(element, binding) {\r\n        if (!binding.value || !binding.value.id) {\r\n            return;\r\n        }\r\n\r\n        const service = getExistingDragDropService(binding.value.id);\r\n\r\n        if (service) {\r\n            service.removeSourceContainer(element);\r\n\r\n            if (service.isFinished()) {\r\n                destroyService(service);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Defines the target of a drag and drop operation.\r\n *\r\n * When using a v-for to display the items, ensure you use a unique :key. Otherwise\r\n * when you .splice() after a drop weird things will happen.\r\n */\r\nexport const DragTarget: Directive<HTMLElement, string | IDragTargetOptions> = {\r\n    mounted(element, binding) {\r\n        const options = getTargetOptions(binding.value);\r\n\r\n        if (!options) {\r\n            console.error(\"DragTarget must have a valid identifier.\");\r\n            return;\r\n        }\r\n\r\n        dragulaScriptPromise.then(() => {\r\n            // This will never be null, but TS doesn't know that because we\r\n            // are inside a function callback.\r\n            if (options) {\r\n                const service = getDragDropService(options.id);\r\n\r\n                service.addTargetContainer(element, options);\r\n            }\r\n        });\r\n    },\r\n\r\n    unmounted(element, binding) {\r\n        const options = getTargetOptions(binding.value);\r\n\r\n        if (!options) {\r\n            return;\r\n        }\r\n\r\n        const service = getExistingDragDropService(options.id);\r\n\r\n        if (service) {\r\n            service.removeTargetContainer(element);\r\n\r\n            if (service.isFinished()) {\r\n                destroyService(service);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Defines the source and target of a drag and drop reorder operation.\r\n *\r\n * When using a v-for to display the items, ensure you use a unique :key. Otherwise\r\n * when you .splice() after a drop weird things will happen.\r\n */\r\nexport const DragReorder: Directive<HTMLElement, IDragSourceOptions> = {\r\n    mounted(element, binding) {\r\n        if (!binding.value || !binding.value.id) {\r\n            console.error(\"DragReorder must have a valid identifier.\");\r\n            return;\r\n        }\r\n\r\n        dragulaScriptPromise.then(() => {\r\n            const service = getDragDropService(binding.value.id);\r\n\r\n            service.addSourceContainer(element, binding.value);\r\n            service.addTargetContainer(element, binding.value);\r\n        });\r\n    },\r\n\r\n    unmounted(element, binding) {\r\n        if (!binding.value || !binding.value.id) {\r\n            return;\r\n        }\r\n\r\n        const service = getExistingDragDropService(binding.value.id);\r\n\r\n        if (service) {\r\n            service.removeTargetContainer(element);\r\n            service.removeSourceContainer(element);\r\n\r\n            if (service.isFinished()) {\r\n                destroyService(service);\r\n            }\r\n        }\r\n    }\r\n};\r\n\r\n/**\r\n * Get the drag source options for re-ordering the sections. This allows the user\r\n * to drag and drop existing sections to move them around the form. The contents\r\n * of the array are modified to match the new order.\r\n *\r\n * @param values The values that can be reordered.\r\n * @param reorder The function to call when items have been reordered.\r\n *\r\n * @returns The IDragSourceOptions object to use for the DragReorder directive.\r\n */\r\nexport function useDragReorder<T>(values: Ref<T[] | undefined | null>, reorder?: ((value: T, beforeValue: T | null) => void)): IDragSourceOptions {\r\n    return {\r\n        id: newGuid(),\r\n        copyElement: false,\r\n        handleSelector: \".reorder-handle\",\r\n        dragDrop(operation) {\r\n            if (operation.targetIndex === undefined || operation.sourceIndex === operation.targetIndex) {\r\n                return;\r\n            }\r\n\r\n            if (!values.value || operation.sourceIndex >= values.value.length) {\r\n                return;\r\n            }\r\n\r\n            const targetIndex = operation.sourceIndex > operation.targetIndex\r\n                ? operation.targetIndex\r\n                : operation.targetIndex + 1;\r\n\r\n            const value = values.value[operation.sourceIndex];\r\n            const beforeValue = targetIndex < values.value.length ? values.value[targetIndex] : null;\r\n\r\n            // Update the values ordered list. Do this operation last because\r\n            // in the future there might be a function parameter that disables\r\n            // the actual modification of the array.\r\n            values.value.splice(operation.sourceIndex, 1);\r\n            values.value.splice(operation.targetIndex, 0, value);\r\n\r\n            if (reorder) {\r\n                reorder(value, beforeValue);\r\n            }\r\n        }\r\n    };\r\n}\r\n"],"names":["dragulaScriptPromise","loadJavaScriptAsync","window","dragula","undefined","DragDropService","constructor","identifier","_defineProperty","id","options","accepts","drakeAccepts","bind","copy","drakeCopy","moves","drakeMoves","revertOnSpill","drake","on","drakeEventDrag","drakeEventDrop","drakeEventOver","drakeEventOut","drakeEventCancel","drakeEventEnd","drakeEventShadow","isFinished","sourceContainers","length","targetContainers","destroy","addSourceContainer","container","containerIndex","findIndex","c","element","push","updateDrakeContainers","addTargetContainer","removeSourceContainer","splice","removeTargetContainer","containers","map","concat","el","elementOptions","find","copyElement","_el$nextElementSiblin","sourceIndex","Array","from","children","indexOf","sourceContainer","sourceSibling","nextElementSibling","handle","sibling","mirrorContainer","startDrag","handleSelector","querySelectorAll","some","n","contains","target","source","sourceOptions","targetOptions","internalOperation","realSibling","classList","targetIndex","acceptDrop","_objectSpread","targetContainer","targetSibling","_el$nextElementSiblin2","dragBegin","dragDrop","lastContainer","dragCancel","dragOver","dragOut","_this$internalOperati","dragEnd","dragShadow","shadow","knownServices","getExistingDragDropService","getDragDropService","service","destroyService","getTargetOptions","value","DragSource","mounted","binding","console","error","then","unmounted","DragTarget","DragReorder","useDragReorder","values","reorder","newGuid","operation","beforeValue"],"mappings":"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"}