{"version":3,"file":"wordCloud.obs.js","sources":["../../../Framework/Controls/wordCloud.obs"],"sourcesContent":["<!-- Copyright by the Spark Development Network; Licensed under the Rock Community License -->\r\n<template>\r\n    <svg ref=\"svgElement\" class=\"rock-word-cloud\" :style=\"svgStyle\"></svg>\r\n</template>\r\n\r\n<script setup lang=\"ts\">\r\n    import { cloud } from \"@Obsidian/Libs/d3\";\r\n    import { PropType, computed, onMounted, ref, watch, onBeforeUnmount } from \"vue\";\r\n\r\n    /** Custom type to hold all our on-screen element information. */\r\n    type WordElement = {\r\n        fontSize: number;\r\n\r\n        x: number;\r\n\r\n        y: number;\r\n\r\n        rotation: number;\r\n\r\n        previousFontSize: number;\r\n\r\n        previousX: number;\r\n\r\n        previousY: number;\r\n\r\n        previousRotation: number;\r\n\r\n        element: SVGTextElement;\r\n    };\r\n\r\n    const props = defineProps({\r\n        /** A list of case-sensitive words to be used in drawing the cloud. */\r\n        words: {\r\n            type: Array as PropType<string[]>,\r\n            default: []\r\n        },\r\n\r\n        /**\r\n         * The width of the cloud SVG. This can be set to an empty string in\r\n         * order to allow CSS to set the width. This can also be a percentage\r\n         * value such as 100%.\r\n         */\r\n        width: {\r\n            type: [Number, String] as PropType<number | string>,\r\n            default: 500\r\n        },\r\n\r\n        /**\r\n         * The height of the cloud SVG. This can be set to an empty string in\r\n         * order to allow CSS to set the height. This can also be a percentage\r\n         * value such as 100%.\r\n         */\r\n        height: {\r\n            type: [Number, String] as PropType<number | string>,\r\n            default: 500\r\n        },\r\n\r\n        /**\r\n         * The number of angles that will be used between minimumAngle and\r\n         * maximumAngle, inclusive. If you provide a value of 3 then you will\r\n         * get 3 total angles: minimumAngle, maximumAngle and the half-way\r\n         * point between the two.\r\n         */\r\n        angleCount: {\r\n            type: Number as PropType<number>,\r\n            default: 5\r\n        },\r\n\r\n        /**\r\n         * The minimum angle to use when rotating the text, this is expressed\r\n         * in degrees with 0 being normal left-to-right text.\r\n         */\r\n        minimumAngle: {\r\n            type: Number as PropType<number>,\r\n            default: -90\r\n        },\r\n\r\n        /**\r\n         * The maximum angle to use when rotating the text, this is expressed\r\n         * in degrees with 0 being normal left-to-right text.\r\n         */\r\n        maximumAngle: {\r\n            type: Number as PropType<number>,\r\n            default: 90\r\n        },\r\n\r\n        /** The font name to use when drawing the words. */\r\n        fontName: {\r\n            type: String as PropType<string>,\r\n            default: \"Impact\"\r\n        },\r\n\r\n        /** The minimum font size to use when drawing the words. */\r\n        minimumFontSize: {\r\n            type: Number as PropType<number>,\r\n            default: 10\r\n        },\r\n\r\n        /** The maximum font size to use when drawing the words. */\r\n        maximumFontSize: {\r\n            type: Number as PropType<number>,\r\n            default: 96\r\n        },\r\n\r\n        /** The list of CSS colors to use when drawing the words. */\r\n        colors: {\r\n            type: Array as PropType<string[]>,\r\n            default: [\"#0193B9\", \"#F2C852\", \"#1DB82B\", \"#2B515D\", \"#ED3223\"]\r\n        },\r\n\r\n        /** The amount of padding, in pixels, to put between words. */\r\n        wordPadding: {\r\n            type: Number as PropType<number>,\r\n            default: 5\r\n        },\r\n\r\n        /**\r\n         * By default the word cloud will preserve the existing size and\r\n         * position of words and then animate them to their new position.\r\n         * Setting this to true will disable that behavior and clear the\r\n         * SVG before rendering the new words.\r\n         */\r\n        autoClear: {\r\n            type: Boolean as PropType<boolean>,\r\n            default: false\r\n        },\r\n\r\n        /**\r\n         * The duration of the animation when placing and drawing the\r\n         * words onto the SVG surface.\r\n         */\r\n        animationDuration: {\r\n            type: Number as PropType<number>,\r\n            default: 350\r\n        },\r\n\r\n        /**\r\n         * The minimum amount of time in milliseconds that must elapse between\r\n         * updates. If multiple updates are requested within this time frame\r\n         * then the additional ones will be deferred until after the interval\r\n         * has elapsed. This interval does not apply when going changing from\r\n         * an empty word list.\r\n         */\r\n        minimumUpdateInterval: {\r\n            type: Number as PropType<number>,\r\n            default: 0\r\n        }\r\n    });\r\n\r\n    const emit = defineEmits<{\r\n        /** Called just before the word cloud begins an update of the surface. */\r\n        (e: \"beginDraw\"): void,\r\n\r\n        /** Called just after the word cloud has finished drawing the words. */\r\n        (e: \"endDraw\"): void\r\n    }>();\r\n\r\n    // #region Values\r\n\r\n    const svgElement = ref<HTMLCanvasElement | null>(null);\r\n    const elements: Record<string, WordElement> = {};\r\n    let animationStartTime: number | null = null;\r\n    let animationFrame: number | null = null;\r\n    let isUpdateRequested = false;\r\n    let resizeObserver: ResizeObserver | null = null;\r\n    let lastObserverSize = { width: 0, height: 0 };\r\n    let lastUpdate: number = 0;\r\n    let deferredUpdateTimer: number | null = null;\r\n\r\n    // #endregion\r\n\r\n    // #region Computed Values\r\n\r\n    /**\r\n     * The style values to be applied to the SVG element.\r\n     */\r\n    const svgStyle = computed((): Record<string, string> => {\r\n        const styles: Record<string, string> = {};\r\n\r\n        if (typeof props.width === \"string\") {\r\n            styles.width = props.width;\r\n        }\r\n        else {\r\n            styles.width = `${props.width}px`;\r\n        }\r\n\r\n        if (typeof props.height === \"string\") {\r\n            styles.height = props.height;\r\n        }\r\n        else {\r\n            styles.height = `${props.height}px`;\r\n        }\r\n\r\n        return styles;\r\n    });\r\n\r\n    /**\r\n     * The angle count after applying sane constraints.\r\n     */\r\n    const constrainedAngleCount = computed((): number => {\r\n        return Math.max(1, Math.min(180, Math.floor(props.angleCount)));\r\n    });\r\n\r\n    /**\r\n     * The calculuated angle positions based on the minimum, maximum and\r\n     * number of angles requested.\r\n     */\r\n    const angles = computed((): number[] => {\r\n        const angleCount = Math.min(180, constrainedAngleCount.value);\r\n\r\n        if (angleCount <= 1) {\r\n            return [(props.minimumAngle + props.maximumAngle) / 2];\r\n        }\r\n        else if (angleCount === 2) {\r\n            return [props.minimumAngle, props.maximumAngle];\r\n        }\r\n        else {\r\n            const angleSize = (props.maximumAngle - props.minimumAngle) / (angleCount - 1);\r\n            const angleList: number[] = [];\r\n\r\n            for (let angle = props.minimumAngle; angle <= props.maximumAngle; angle += angleSize) {\r\n                angleList.push(angle);\r\n            }\r\n\r\n            return angleList;\r\n        }\r\n    });\r\n\r\n    // #endregion\r\n\r\n    // #region Functions\r\n\r\n    /**\r\n     * Gets the width of the drawing surface.\r\n     */\r\n    function getWidth(): number {\r\n        return svgElement.value?.clientWidth ?? 0;\r\n    }\r\n\r\n    /**\r\n     * Gets the height of the drawing surface.\r\n     */\r\n    function getHeight(): number {\r\n        return svgElement.value?.clientHeight ?? 0;\r\n    }\r\n\r\n    /**\r\n     * Creates a scale function that will translate an input value to a scaled\r\n     * output value. This uses a logarithmic calculation.\r\n     *\r\n     * @param outputMin The minimum value of the scaled output.\r\n     * @param outputMax The maximum value of the scaled output.\r\n     * @param inputMin The minimum value of the input.\r\n     * @param inputMax The maximum value of the input.\r\n     */\r\n    function createLogScale(outputMin: number, outputMax: number, inputMin: number, inputMax: number): ((value: number) => number) {\r\n        const logmin = Math.log(inputMin);\r\n        const logmax = Math.log(inputMax);\r\n        const outputRange = outputMax - outputMin;\r\n\r\n        return (value: number): number => {\r\n            if (value === inputMin && value === inputMax) {\r\n                return outputMin;\r\n            }\r\n\r\n            return (((Math.log(value) - logmin) / (logmax - logmin)) * outputRange) + outputMin;\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Creates a consumer in the form of a function that will take the next\r\n     * item in the list of values each time it is called. When the end is\r\n     * reached then it starts over from the beginning.\r\n     *\r\n     * @param values The values to be sequentially consumed.\r\n     * @param seed The starting index to use when creating the consumer.\r\n     */\r\n    function createSequentialConsumer<T>(values: T[], seed: number): (() => T | undefined) {\r\n        const items: T[] = [...values];\r\n        let index = seed % items.length;\r\n\r\n        return (): T | undefined => {\r\n            if (items.length === 0) {\r\n                return undefined;\r\n            }\r\n\r\n            if (index >= items.length) {\r\n                index = 0;\r\n            }\r\n\r\n            return items[index++];\r\n        };\r\n    }\r\n\r\n    /**\r\n     * Maps a progress value to the final value to be used during an animation\r\n     * frame.\r\n     *\r\n     * @param startValue The value at the start of the animation.\r\n     * @param endValue The value at the end of the animation.\r\n     * @param progress The progress of the animation, between 0 and 1 inclusive.\r\n     */\r\n    function mapAnimationValue(startValue: number, endValue: number, progress: number): number {\r\n        // Bezier easing.\r\n        let progressCurve = progress * progress * (3.0 - 2.0 * progress);\r\n\r\n        return ((endValue - startValue) * progressCurve) + startValue;\r\n    }\r\n\r\n    /**\r\n     * Renders the words after they have been placed on a virtual canvas.\r\n     *\r\n     * @param words The words and their position and size information.\r\n     */\r\n    function renderWords(words: cloud.Word[]): void {\r\n        if (!svgElement.value) {\r\n            return;\r\n        }\r\n\r\n        // Get or create the node that will represent the graphics surface.\r\n        // It is translated so that 0,0 is the center of the SVG.\r\n        let g = svgElement.value.firstChild as SVGGElement | null;\r\n\r\n        if (!g) {\r\n            g = document.createElementNS(\"http://www.w3.org/2000/svg\", \"g\");\r\n            svgElement.value.appendChild(g);\r\n        }\r\n\r\n        g.setAttribute(\"transform\", `translate(${getWidth() / 2}, ${getHeight() / 2})`);\r\n\r\n        // Remove all children if we are configured to automatically clear\r\n        // on all updates.\r\n        if (props.autoClear) {\r\n            while (g.firstChild) {\r\n                g.firstChild.remove();\r\n            }\r\n        }\r\n\r\n        const colorConsumer = createSequentialConsumer(props.colors, Object.keys(elements).length);\r\n\r\n        for (let index = 0; index < words.length; index += 1) {\r\n            const word = words[index];\r\n            if (!word.text) {\r\n                continue;\r\n            }\r\n\r\n            let wordElement = elements[word.text];\r\n\r\n            // If this is a brand new word then initialize the new element.\r\n            if (!wordElement) {\r\n                const textNode = document.createElementNS(\"http://www.w3.org/2000/svg\", \"text\");\r\n\r\n                // The element will start at center with a size of 0 and then\r\n                // animate to the final position.\r\n                textNode.setAttribute(\"text-anchor\", \"middle\");\r\n                textNode.style.fontFamily = word.font ?? \"inherit\";\r\n                textNode.style.fill = colorConsumer() ?? \"inherit\";\r\n                textNode.style.transform = \"translate(0px, 0px) rotate(0deg)\";\r\n                textNode.textContent = word.text;\r\n                g.appendChild(textNode);\r\n\r\n                wordElement = {\r\n                    element: textNode,\r\n                    previousFontSize: 0,\r\n                    previousRotation: 0,\r\n                    previousX: 0,\r\n                    previousY: 0,\r\n                    fontSize: word.size ?? 0,\r\n                    rotation: word.rotate ?? 0,\r\n                    x: word.x ?? 0,\r\n                    y: word.y ?? 0\r\n                };\r\n\r\n                elements[word.text] = wordElement;\r\n            }\r\n            else {\r\n                // An existing word element was found, update it's new size and\r\n                // position for animation.\r\n                wordElement.fontSize = word.size ?? 0;\r\n                wordElement.rotation = word.rotate ?? 0;\r\n                wordElement.x = word.x ?? 0;\r\n                wordElement.y = word.y ?? 0;\r\n            }\r\n        }\r\n\r\n        // Find any old elements that need to be removed.\r\n        const existingWords = words.filter(w => w.text).map(w => w.text);\r\n        for (const wordKey of Object.keys(elements)) {\r\n            if (!existingWords.includes(wordKey)) {\r\n                elements[wordKey].fontSize = 0;\r\n                elements[wordKey].x = 0;\r\n                elements[wordKey].y = 0;\r\n                elements[wordKey].rotation = 0;\r\n            }\r\n        }\r\n\r\n        animationFrame = requestAnimationFrame(animateWordsFrame);\r\n    }\r\n\r\n    /**\r\n     * Performs the calculations required for a single animation frame. The new\r\n     * position and sizes are determined and then the elements updated to\r\n     * reflect those new values.\r\n     *\r\n     * @param time The high-resolution time when this animation frame began.\r\n     */\r\n    function animateWordsFrame(time: number): void {\r\n        // If this is the first frame then initialize as such.\r\n        if (animationStartTime === null) {\r\n            animationStartTime = time;\r\n        }\r\n\r\n        // Determine the progress in the animation sequence.\r\n        const duration = Math.min(time - animationStartTime, props.animationDuration);\r\n        const progress = duration / props.animationDuration;\r\n        const isLastFrame = duration === props.animationDuration;\r\n\r\n        for (const word of Object.keys(elements)) {\r\n            const wordElement = elements[word];\r\n\r\n            // Map the values for what they should be at this frame.\r\n            const fontSize = mapAnimationValue(wordElement.previousFontSize, wordElement.fontSize, progress);\r\n            const x = mapAnimationValue(wordElement.previousX, wordElement.x, progress);\r\n            const y = mapAnimationValue(wordElement.previousY, wordElement.y, progress);\r\n            const rotation = mapAnimationValue(wordElement.previousRotation, wordElement.rotation, progress);\r\n\r\n            // Update the element to be positioned and sized correctly.\r\n            wordElement.element.style.fontSize = `${fontSize}px`;\r\n            wordElement.element.style.transform = `translate(${x}px, ${y}px) rotate(${rotation}deg)`;\r\n\r\n            // If this is the last frame then remove any elements that have been\r\n            // sized away, otherwise update the previous coordinates to the new\r\n            // coordinates.\r\n            if (isLastFrame) {\r\n                if (wordElement.fontSize === 0) {\r\n                    wordElement.element.remove();\r\n                    delete (elements[word]);\r\n                }\r\n                else {\r\n                    wordElement.previousFontSize = wordElement.fontSize;\r\n                    wordElement.previousX = wordElement.x;\r\n                    wordElement.previousY = wordElement.y;\r\n                    wordElement.previousRotation = wordElement.rotation;\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!isLastFrame) {\r\n            animationFrame = requestAnimationFrame(animateWordsFrame);\r\n        }\r\n        else {\r\n            animationStartTime = null;\r\n            animationFrame = null;\r\n            emit(\"endDraw\");\r\n\r\n            // If an update was requested while we were animating, start it now.\r\n            if (isUpdateRequested) {\r\n                processWords();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Generates the word cloud based on all current configuration.\r\n     */\r\n    function processWords(): void {\r\n        isUpdateRequested = false;\r\n        lastUpdate = Date.now();\r\n\r\n        if (!svgElement.value) {\r\n            return;\r\n        }\r\n\r\n        emit(\"beginDraw\");\r\n\r\n        if (props.words.length === 0) {\r\n            return renderWords([]);\r\n        }\r\n\r\n        const wordLookup: Record<string, number> = {};\r\n\r\n        // Count how many times each word appears.\r\n        for (const word of props.words) {\r\n            wordLookup[word] = (wordLookup[word] ?? 0) + 1;\r\n        }\r\n\r\n        // Translate that into a cloud word object and then sort\r\n        // it ascending.\r\n        const words: cloud.Word[] = Object.entries(wordLookup)\r\n            .map(e => ({ text: e[0], size: e[1] }))\r\n            .sort((a, b) => a.size - b.size);\r\n\r\n        // Get the min/max word counts and create the scale.\r\n        const min = Math.min(...words.map(w => w.size ?? 0));\r\n        const max = Math.max(...words.map(w => w.size ?? 0));\r\n        const fontSizeScale = createLogScale(props.minimumFontSize, props.maximumFontSize, min, max);\r\n\r\n        cloud()\r\n            .size([getWidth(), getHeight()])\r\n            .timeInterval(25)\r\n            .spiral(\"archimedean\")\r\n            .words(words)\r\n            .padding(5)\r\n            .rotate(() => angles.value[Math.floor(Math.random() * angles.value.length)])\r\n            .font(props.fontName)\r\n            .fontSize(d => Math.floor(fontSizeScale(d.size ?? 0)))\r\n            .on(\"end\", renderWords)\r\n            .start();\r\n    }\r\n\r\n    /**\r\n     * Request an update to the SVG. If we are currently animating then just\r\n     * queue up a new update request.\r\n     */\r\n    function requestUpdate(ignoreSize: boolean): void {\r\n        if (!ignoreSize && lastObserverSize.width === getWidth() && lastObserverSize.height === getHeight()) {\r\n            return;\r\n        }\r\n\r\n        lastObserverSize = { width: getWidth(), height: getHeight() };\r\n\r\n        if (animationFrame === null) {\r\n            processWords();\r\n        }\r\n        else {\r\n            isUpdateRequested = true;\r\n        }\r\n    }\r\n\r\n    // #endregion\r\n\r\n    onMounted(() => {\r\n        if (!svgElement.value) {\r\n            return;\r\n        }\r\n\r\n        // Watch for changes to the size of the SVG and re-render.\r\n        if (window.ResizeObserver) {\r\n            lastObserverSize = { width: getWidth(), height: getHeight() };\r\n            resizeObserver = new ResizeObserver(() => {\r\n                requestUpdate(false);\r\n            });\r\n\r\n            resizeObserver.observe(svgElement.value);\r\n        }\r\n\r\n        requestUpdate(true);\r\n    });\r\n\r\n    // #endregion\r\n\r\n    onBeforeUnmount(() => {\r\n        resizeObserver?.disconnect();\r\n    });\r\n\r\n    // Watch for changes to any of these values and re-render.\r\n    const requestUpdateValues = [\r\n        () => props.words,\r\n        () => props.angleCount,\r\n        () => props.minimumAngle,\r\n        () => props.maximumAngle,\r\n        () => props.fontName,\r\n        () => props.minimumFontSize,\r\n        () => props.maximumFontSize,\r\n        () => props.colors,\r\n        () => props.wordPadding\r\n    ];\r\n\r\n    watch(requestUpdateValues, () => {\r\n        if (deferredUpdateTimer) {\r\n            return;\r\n        }\r\n\r\n        if (props.minimumUpdateInterval > 0 && lastUpdate > 0 && Object.keys(elements).length > 0) {\r\n            const period = lastUpdate + props.minimumUpdateInterval - Date.now();\r\n\r\n            if (period > 0) {\r\n                deferredUpdateTimer = window.setTimeout(() => {\r\n                    deferredUpdateTimer = null;\r\n                    requestUpdate(true);\r\n                }, period);\r\n\r\n                return;\r\n            }\r\n        }\r\n\r\n        requestUpdate(true);\r\n    });\r\n</script>\r\n"],"names":["svgElement","ref","elements","animationStartTime","animationFrame","isUpdateRequested","resizeObserver","lastObserverSize","width","height","lastUpdate","deferredUpdateTimer","svgStyle","computed","styles","props","concat","constrainedAngleCount","Math","max","min","floor","angleCount","angles","value","minimumAngle","maximumAngle","angleSize","angleList","angle","push","getWidth","_svgElement$value$cli","_svgElement$value","clientWidth","getHeight","_svgElement$value$cli2","_svgElement$value2","clientHeight","createLogScale","outputMin","outputMax","inputMin","inputMax","logmin","log","logmax","outputRange","createSequentialConsumer","values","seed","items","index","length","undefined","mapAnimationValue","startValue","endValue","progress","progressCurve","renderWords","words","g","firstChild","document","createElementNS","appendChild","setAttribute","autoClear","remove","colorConsumer","colors","Object","keys","word","text","wordElement","_word$font","_colorConsumer","_word$size","_word$rotate","_word$x","_word$y","textNode","style","fontFamily","font","fill","transform","textContent","element","previousFontSize","previousRotation","previousX","previousY","fontSize","size","rotation","rotate","x","y","_word$size2","_word$rotate2","_word$x2","_word$y2","existingWords","filter","w","map","_i","_Object$keys","wordKey","includes","requestAnimationFrame","animateWordsFrame","time","duration","animationDuration","isLastFrame","_i2","_Object$keys2","emit","processWords","Date","now","wordLookup","_iterator","_createForOfIteratorHelper","_step","s","n","done","_wordLookup$word","err","e","f","entries","sort","a","b","_w$size","_w$size2","fontSizeScale","minimumFontSize","maximumFontSize","cloud","timeInterval","spiral","padding","random","fontName","d","_d$size","on","start","requestUpdate","ignoreSize","onMounted","window","ResizeObserver","observe","onBeforeUnmount","_resizeObserver","disconnect","requestUpdateValues","wordPadding","watch","minimumUpdateInterval","period","setTimeout"],"mappings":"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"}