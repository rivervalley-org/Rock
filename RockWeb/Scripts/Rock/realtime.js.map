{"version":3,"file":"realtime.js","mappings":"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","sources":["webpack:///./node_modules/jquery-deferred/index.js","webpack:///./node_modules/jquery-deferred/lib/jquery-callbacks.js","webpack:///./node_modules/jquery-deferred/lib/jquery-core.js","webpack:///./node_modules/jquery-deferred/lib/jquery-deferred.js","webpack:///./node_modules/jquery-param/jquery-param.js","webpack:///./node_modules/mitt/dist/mitt.js","webpack:///./node_modules/signalr-no-jquery/build/jQueryShim.js","webpack:///./node_modules/signalr-no-jquery/build/signalR.js","webpack:///./src/realtime/aspNetEngine.ts","webpack:///./src/realtime/engine.ts","webpack:///./src/realtime/index.ts","webpack:///./src/realtime/topic.ts","webpack:///webpack/bootstrap","webpack:///webpack/startup"],"sourcesContent":["\nmodule.exports = require('./lib/jquery-deferred');","var jQuery = module.exports = require(\"./jquery-core.js\"),\n\tcore_rspace = /\\s+/;\n/**\n* jQuery Callbacks\n*\n* Code from: https://github.com/jquery/jquery/blob/master/src/callbacks.js\n*\n*/\n\n\n// String to Object options format cache\nvar optionsCache = {};\n\n// Convert String-formatted options into Object-formatted ones and store in cache\nfunction createOptions( options ) {\n\tvar object = optionsCache[ options ] = {};\n\tjQuery.each( options.split( core_rspace ), function( _, flag ) {\n\t\tobject[ flag ] = true;\n\t});\n\treturn object;\n}\n\n/*\n * Create a callback list using the following parameters:\n *\n *\toptions: an optional list of space-separated options that will change how\n *\t\t\tthe callback list behaves or a more traditional option object\n *\n * By default a callback list will act like an event callback list and can be\n * \"fired\" multiple times.\n *\n * Possible options:\n *\n *\tonce:\t\t\twill ensure the callback list can only be fired once (like a Deferred)\n *\n *\tmemory:\t\t\twill keep track of previous values and will call any callback added\n *\t\t\t\t\tafter the list has been fired right away with the latest \"memorized\"\n *\t\t\t\t\tvalues (like a Deferred)\n *\n *\tunique:\t\t\twill ensure a callback can only be added once (no duplicate in the list)\n *\n *\tstopOnFalse:\tinterrupt callings when a callback returns false\n *\n */\njQuery.Callbacks = function( options ) {\n\n\t// Convert options from String-formatted to Object-formatted if needed\n\t// (we check in cache first)\n\toptions = typeof options === \"string\" ?\n\t\t( optionsCache[ options ] || createOptions( options ) ) :\n\t\tjQuery.extend( {}, options );\n\n\tvar // Last fire value (for non-forgettable lists)\n\t\tmemory,\n\t\t// Flag to know if list was already fired\n\t\tfired,\n\t\t// Flag to know if list is currently firing\n\t\tfiring,\n\t\t// First callback to fire (used internally by add and fireWith)\n\t\tfiringStart,\n\t\t// End of the loop when firing\n\t\tfiringLength,\n\t\t// Index of currently firing callback (modified by remove if needed)\n\t\tfiringIndex,\n\t\t// Actual callback list\n\t\tlist = [],\n\t\t// Stack of fire calls for repeatable lists\n\t\tstack = !options.once && [],\n\t\t// Fire callbacks\n\t\tfire = function( data ) {\n\t\t\tmemory = options.memory && data;\n\t\t\tfired = true;\n\t\t\tfiringIndex = firingStart || 0;\n\t\t\tfiringStart = 0;\n\t\t\tfiringLength = list.length;\n\t\t\tfiring = true;\n\t\t\tfor ( ; list && firingIndex < firingLength; firingIndex++ ) {\n\t\t\t\tif ( list[ firingIndex ].apply( data[ 0 ], data[ 1 ] ) === false && options.stopOnFalse ) {\n\t\t\t\t\tmemory = false; // To prevent further calls using add\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tfiring = false;\n\t\t\tif ( list ) {\n\t\t\t\tif ( stack ) {\n\t\t\t\t\tif ( stack.length ) {\n\t\t\t\t\t\tfire( stack.shift() );\n\t\t\t\t\t}\n\t\t\t\t} else if ( memory ) {\n\t\t\t\t\tlist = [];\n\t\t\t\t} else {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t}\n\t\t},\n\t\t// Actual Callbacks object\n\t\tself = {\n\t\t\t// Add a callback or a collection of callbacks to the list\n\t\t\tadd: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\t// First, we save the current length\n\t\t\t\t\tvar start = list.length;\n\t\t\t\t\t(function add( args ) {\n\t\t\t\t\t\tjQuery.each( args, function( _, arg ) {\n\t\t\t\t\t\t\tvar type = jQuery.type( arg );\n\t\t\t\t\t\t\tif ( type === \"function\" ) {\n\t\t\t\t\t\t\t\tif ( !options.unique || !self.has( arg ) ) {\n\t\t\t\t\t\t\t\t\tlist.push( arg );\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} else if ( arg && arg.length && type !== \"string\" ) {\n\t\t\t\t\t\t\t\t// Inspect recursively\n\t\t\t\t\t\t\t\tadd( arg );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\t\t\t\t\t})( arguments );\n\t\t\t\t\t// Do we need to add the callbacks to the\n\t\t\t\t\t// current firing batch?\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tfiringLength = list.length;\n\t\t\t\t\t// With memory, if we're not firing then\n\t\t\t\t\t// we should call right away\n\t\t\t\t\t} else if ( memory ) {\n\t\t\t\t\t\tfiringStart = start;\n\t\t\t\t\t\tfire( memory );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Remove a callback from the list\n\t\t\tremove: function() {\n\t\t\t\tif ( list ) {\n\t\t\t\t\tjQuery.each( arguments, function( _, arg ) {\n\t\t\t\t\t\tvar index;\n\t\t\t\t\t\twhile( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {\n\t\t\t\t\t\t\tlist.splice( index, 1 );\n\t\t\t\t\t\t\t// Handle firing indexes\n\t\t\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\t\t\tif ( index <= firingLength ) {\n\t\t\t\t\t\t\t\t\tfiringLength--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tif ( index <= firingIndex ) {\n\t\t\t\t\t\t\t\t\tfiringIndex--;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Control if a given callback is in the list\n\t\t\thas: function( fn ) {\n\t\t\t\treturn jQuery.inArray( fn, list ) > -1;\n\t\t\t},\n\t\t\t// Remove all callbacks from the list\n\t\t\tempty: function() {\n\t\t\t\tlist = [];\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Have the list do nothing anymore\n\t\t\tdisable: function() {\n\t\t\t\tlist = stack = memory = undefined;\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it disabled?\n\t\t\tdisabled: function() {\n\t\t\t\treturn !list;\n\t\t\t},\n\t\t\t// Lock the list in its current state\n\t\t\tlock: function() {\n\t\t\t\tstack = undefined;\n\t\t\t\tif ( !memory ) {\n\t\t\t\t\tself.disable();\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Is it locked?\n\t\t\tlocked: function() {\n\t\t\t\treturn !stack;\n\t\t\t},\n\t\t\t// Call all callbacks with the given context and arguments\n\t\t\tfireWith: function( context, args ) {\n\t\t\t\targs = args || [];\n\t\t\t\targs = [ context, args.slice ? args.slice() : args ];\n\t\t\t\tif ( list && ( !fired || stack ) ) {\n\t\t\t\t\tif ( firing ) {\n\t\t\t\t\t\tstack.push( args );\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfire( args );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// Call all the callbacks with the given arguments\n\t\t\tfire: function() {\n\t\t\t\tself.fireWith( this, arguments );\n\t\t\t\treturn this;\n\t\t\t},\n\t\t\t// To know if the callbacks have already been called at least once\n\t\t\tfired: function() {\n\t\t\t\treturn !!fired;\n\t\t\t}\n\t\t};\n\n\treturn self;\n};\n\n","/**\n* jQuery core object.\n*\n* Worker with jQuery deferred\n*\n* Code from: https://github.com/jquery/jquery/blob/master/src/core.js\n*\n*/\n\nvar jQuery = module.exports = {\n\ttype: type\n\t, isArray: isArray\n\t, isFunction: isFunction\n\t, isPlainObject: isPlainObject\n\t, each: each\n\t, extend: extend\n\t, noop: function() {}\n};\n\nvar toString = Object.prototype.toString;\n\nvar class2type = {};\n// Populate the class2type map\n\"Boolean Number String Function Array Date RegExp Object\".split(\" \").forEach(function(name) {\n\tclass2type[ \"[object \" + name + \"]\" ] = name.toLowerCase();\n});\n\n\nfunction type( obj ) {\n\treturn obj == null ?\n\t\tString( obj ) :\n\t\t\tclass2type[ toString.call(obj) ] || \"object\";\n}\n\nfunction isFunction( obj ) {\n\treturn jQuery.type(obj) === \"function\";\n}\n\nfunction isArray( obj ) {\n\treturn jQuery.type(obj) === \"array\";\n}\n\nfunction each( object, callback, args ) {\n\tvar name, i = 0,\n\tlength = object.length,\n\tisObj = length === undefined || isFunction( object );\n\n\tif ( args ) {\n\t\tif ( isObj ) {\n\t\t\tfor ( name in object ) {\n\t\t\t\tif ( callback.apply( object[ name ], args ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( ; i < length; ) {\n\t\t\t\tif ( callback.apply( object[ i++ ], args ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// A special, fast, case for the most common use of each\n\t} else {\n\t\tif ( isObj ) {\n\t\t\tfor ( name in object ) {\n\t\t\t\tif ( callback.call( object[ name ], name, object[ name ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t} else {\n\t\t\tfor ( ; i < length; ) {\n\t\t\t\tif ( callback.call( object[ i ], i, object[ i++ ] ) === false ) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn object;\n}\n\nfunction isPlainObject( obj ) {\n\t// Must be an Object.\n\tif ( !obj || jQuery.type(obj) !== \"object\" ) {\n\t\treturn false;\n\t}\n\treturn true;\n}\n\nfunction extend() {\n\tvar options, name, src, copy, copyIsArray, clone,\n\ttarget = arguments[0] || {},\n\ti = 1,\n\tlength = arguments.length,\n\tdeep = false;\n\n\t// Handle a deep copy situation\n\tif ( typeof target === \"boolean\" ) {\n\t\tdeep = target;\n\t\ttarget = arguments[1] || {};\n\t\t// skip the boolean and the target\n\t\ti = 2;\n\t}\n\n\t// Handle case when target is a string or something (possible in deep copy)\n\tif ( typeof target !== \"object\" && !jQuery.isFunction(target) ) {\n\t\ttarget = {};\n\t}\n\n\t// extend jQuery itself if only one argument is passed\n\tif ( length === i ) {\n\t\ttarget = this;\n\t\t--i;\n\t}\n\n\tfor ( ; i < length; i++ ) {\n\t\t// Only deal with non-null/undefined values\n\t\tif ( (options = arguments[ i ]) != null ) {\n\t\t\t// Extend the base object\n\t\t\tfor ( name in options ) {\n\t\t\t\tsrc = target[ name ];\n\t\t\t\tcopy = options[ name ];\n\n\t\t\t\t// Prevent never-ending loop\n\t\t\t\tif ( target === copy ) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\t// Recurse if we're merging plain objects or arrays\n\t\t\t\tif ( deep && copy && ( jQuery.isPlainObject(copy) || (copyIsArray = jQuery.isArray(copy)) ) ) {\n\t\t\t\t\tif ( copyIsArray ) {\n\t\t\t\t\t\tcopyIsArray = false;\n\t\t\t\t\t\tclone = src && jQuery.isArray(src) ? src : [];\n\n\t\t\t\t\t} else {\n\t\t\t\t\t\tclone = src && jQuery.isPlainObject(src) ? src : {};\n\t\t\t\t\t}\n\n\t\t\t\t\t// Never move original objects, clone them\n\t\t\t\t\ttarget[ name ] = jQuery.extend( deep, clone, copy );\n\n\t\t\t\t\t// Don't bring in undefined values\n\t\t\t\t} else if ( copy !== undefined ) {\n\t\t\t\t\ttarget[ name ] = copy;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\t// Return the modified object\n\treturn target;\n};\n\n\n","\n/*!\n* jquery-deferred\n* Copyright(c) 2011 Hidden <zzdhidden@gmail.com>\n* MIT Licensed\n*/\n\n/**\n* Library version.\n*/\n\nvar jQuery = module.exports = require(\"./jquery-callbacks.js\"),\n\tcore_slice = Array.prototype.slice;\n\n/**\n* jQuery deferred\n*\n* Code from: https://github.com/jquery/jquery/blob/master/src/deferred.js\n* Doc: http://api.jquery.com/category/deferred-object/\n*\n*/\n\njQuery.extend({\n\n\tDeferred: function( func ) {\n\t\tvar tuples = [\n\t\t\t\t// action, add listener, listener list, final state\n\t\t\t\t[ \"resolve\", \"done\", jQuery.Callbacks(\"once memory\"), \"resolved\" ],\n\t\t\t\t[ \"reject\", \"fail\", jQuery.Callbacks(\"once memory\"), \"rejected\" ],\n\t\t\t\t[ \"notify\", \"progress\", jQuery.Callbacks(\"memory\") ]\n\t\t\t],\n\t\t\tstate = \"pending\",\n\t\t\tpromise = {\n\t\t\t\tstate: function() {\n\t\t\t\t\treturn state;\n\t\t\t\t},\n\t\t\t\talways: function() {\n\t\t\t\t\tdeferred.done( arguments ).fail( arguments );\n\t\t\t\t\treturn this;\n\t\t\t\t},\n\t\t\t\tthen: function( /* fnDone, fnFail, fnProgress */ ) {\n\t\t\t\t\tvar fns = arguments;\n\t\t\t\t\treturn jQuery.Deferred(function( newDefer ) {\n\t\t\t\t\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\t\t\t\t\tvar action = tuple[ 0 ],\n\t\t\t\t\t\t\t\tfn = fns[ i ];\n\t\t\t\t\t\t\t// deferred[ done | fail | progress ] for forwarding actions to newDefer\n\t\t\t\t\t\t\tdeferred[ tuple[1] ]( jQuery.isFunction( fn ) ?\n\t\t\t\t\t\t\t\tfunction() {\n\t\t\t\t\t\t\t\t\tvar returned = fn.apply( this, arguments );\n\t\t\t\t\t\t\t\t\tif ( returned && jQuery.isFunction( returned.promise ) ) {\n\t\t\t\t\t\t\t\t\t\treturned.promise()\n\t\t\t\t\t\t\t\t\t\t\t.done( newDefer.resolve )\n\t\t\t\t\t\t\t\t\t\t\t.fail( newDefer.reject )\n\t\t\t\t\t\t\t\t\t\t\t.progress( newDefer.notify );\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tnewDefer[ action + \"With\" ]( this === deferred ? newDefer : this, [ returned ] );\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} :\n\t\t\t\t\t\t\t\tnewDefer[ action ]\n\t\t\t\t\t\t\t);\n\t\t\t\t\t\t});\n\t\t\t\t\t\tfns = null;\n\t\t\t\t\t}).promise();\n\t\t\t\t},\n\t\t\t\t// Get a promise for this deferred\n\t\t\t\t// If obj is provided, the promise aspect is added to the object\n\t\t\t\tpromise: function( obj ) {\n\t\t\t\t\treturn obj != null ? jQuery.extend( obj, promise ) : promise;\n\t\t\t\t}\n\t\t\t},\n\t\t\tdeferred = {};\n\n\t\t// Keep pipe for back-compat\n\t\tpromise.pipe = promise.then;\n\n\t\t// Add list-specific methods\n\t\tjQuery.each( tuples, function( i, tuple ) {\n\t\t\tvar list = tuple[ 2 ],\n\t\t\t\tstateString = tuple[ 3 ];\n\n\t\t\t// promise[ done | fail | progress ] = list.add\n\t\t\tpromise[ tuple[1] ] = list.add;\n\n\t\t\t// Handle state\n\t\t\tif ( stateString ) {\n\t\t\t\tlist.add(function() {\n\t\t\t\t\t// state = [ resolved | rejected ]\n\t\t\t\t\tstate = stateString;\n\n\t\t\t\t// [ reject_list | resolve_list ].disable; progress_list.lock\n\t\t\t\t}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );\n\t\t\t}\n\n\t\t\t// deferred[ resolve | reject | notify ] = list.fire\n\t\t\tdeferred[ tuple[0] ] = list.fire;\n\t\t\tdeferred[ tuple[0] + \"With\" ] = list.fireWith;\n\t\t});\n\n\t\t// Make the deferred a promise\n\t\tpromise.promise( deferred );\n\n\t\t// Call given func if any\n\t\tif ( func ) {\n\t\t\tfunc.call( deferred, deferred );\n\t\t}\n\n\t\t// All done!\n\t\treturn deferred;\n\t},\n\n\t// Deferred helper\n\twhen: function( subordinate /* , ..., subordinateN */ ) {\n\t\tvar i = 0,\n\t\t\tresolveValues = core_slice.call( arguments ),\n\t\t\tlength = resolveValues.length,\n\n\t\t\t// the count of uncompleted subordinates\n\t\t\tremaining = length !== 1 || ( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,\n\n\t\t\t// the master Deferred. If resolveValues consist of only a single Deferred, just use that.\n\t\t\tdeferred = remaining === 1 ? subordinate : jQuery.Deferred(),\n\n\t\t\t// Update function for both resolve and progress values\n\t\t\tupdateFunc = function( i, contexts, values ) {\n\t\t\t\treturn function( value ) {\n\t\t\t\t\tcontexts[ i ] = this;\n\t\t\t\t\tvalues[ i ] = arguments.length > 1 ? core_slice.call( arguments ) : value;\n\t\t\t\t\tif( values === progressValues ) {\n\t\t\t\t\t\tdeferred.notifyWith( contexts, values );\n\t\t\t\t\t} else if ( !( --remaining ) ) {\n\t\t\t\t\t\tdeferred.resolveWith( contexts, values );\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t},\n\n\t\t\tprogressValues, progressContexts, resolveContexts;\n\n\t\t// add listeners to Deferred subordinates; treat others as resolved\n\t\tif ( length > 1 ) {\n\t\t\tprogressValues = new Array( length );\n\t\t\tprogressContexts = new Array( length );\n\t\t\tresolveContexts = new Array( length );\n\t\t\tfor ( ; i < length; i++ ) {\n\t\t\t\tif ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {\n\t\t\t\t\tresolveValues[ i ].promise()\n\t\t\t\t\t\t.done( updateFunc( i, resolveContexts, resolveValues ) )\n\t\t\t\t\t\t.fail( deferred.reject )\n\t\t\t\t\t\t.progress( updateFunc( i, progressContexts, progressValues ) );\n\t\t\t\t} else {\n\t\t\t\t\t--remaining;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// if we're not waiting on anything, resolve the master\n\t\tif ( !remaining ) {\n\t\t\tdeferred.resolveWith( resolveContexts, resolveValues );\n\t\t}\n\n\t\treturn deferred.promise();\n\t}\n});\n","/**\n * @preserve jquery-param (c) 2015 KNOWLEDGECODE | MIT\n */\n(function (global) {\n    'use strict';\n\n    var param = function (a) {\n        var s = [], rbracket = /\\[\\]$/,\n            isArray = function (obj) {\n                return Object.prototype.toString.call(obj) === '[object Array]';\n            }, add = function (k, v) {\n                v = typeof v === 'function' ? v() : v === null ? '' : v === undefined ? '' : v;\n                s[s.length] = encodeURIComponent(k) + '=' + encodeURIComponent(v);\n            }, buildParams = function (prefix, obj) {\n                var i, len, key;\n\n                if (prefix) {\n                    if (isArray(obj)) {\n                        for (i = 0, len = obj.length; i < len; i++) {\n                            if (rbracket.test(prefix)) {\n                                add(prefix, obj[i]);\n                            } else {\n                                buildParams(prefix + '[' + (typeof obj[i] === 'object' ? i : '') + ']', obj[i]);\n                            }\n                        }\n                    } else if (obj && String(obj) === '[object Object]') {\n                        for (key in obj) {\n                            buildParams(prefix + '[' + key + ']', obj[key]);\n                        }\n                    } else {\n                        add(prefix, obj);\n                    }\n                } else if (isArray(obj)) {\n                    for (i = 0, len = obj.length; i < len; i++) {\n                        add(obj[i].name, obj[i].value);\n                    }\n                } else {\n                    for (key in obj) {\n                        buildParams(key, obj[key]);\n                    }\n                }\n                return s;\n            };\n\n        return buildParams('', a).join('&').replace(/%20/g, '+');\n    };\n\n    if (typeof module === 'object' && typeof module.exports === 'object') {\n        module.exports = param;\n    } else if (typeof define === 'function' && define.amd) {\n        define([], function () {\n            return param;\n        });\n    } else {\n        global.param = param;\n    }\n\n}(this));\n\n","module.exports=function(n){return{all:n=n||new Map,on:function(e,t){var i=n.get(e);i?i.push(t):n.set(e,[t])},off:function(e,t){var i=n.get(e);i&&(t?i.splice(i.indexOf(t)>>>0,1):n.set(e,[]))},emit:function(e,t){var i=n.get(e);i&&i.slice().map(function(n){n(t)}),(i=n.get(\"*\"))&&i.slice().map(function(n){n(e,t)})}}};\n//# sourceMappingURL=mitt.js.map\n","'use strict';\r\n\r\nvar jQueryDeferred = require('jquery-deferred');\r\nvar jQueryParam = require('jquery-param');\r\n\r\nvar jqueryFunction = function jqueryFunction(subject) {\r\n  var events = subject.events || {};\r\n\r\n  if (subject && subject === subject.window) return {\r\n    0: subject,\r\n    load: function load(handler) {\r\n      return subject.addEventListener('load', handler, false);\r\n    },\r\n    bind: function bind(event, handler) {\r\n      return subject.addEventListener(event, handler, false);\r\n    },\r\n    unbind: function unbind(event, handler) {\r\n      return subject.removeEventListener(event, handler, false);\r\n    }\r\n  };\r\n\r\n  return {\r\n    0: subject,\r\n\r\n    unbind: function unbind(event, handler) {\r\n      var handlers = events[event] || [];\r\n\r\n      if (handler) {\r\n        var idx = handlers.indexOf(handler);\r\n        if (idx !== -1) handlers.splice(idx, 1);\r\n      } else handlers = [];\r\n\r\n      events[event] = handlers;\r\n      subject.events = events;\r\n    },\r\n    bind: function bind(event, handler) {\r\n      var current = events[event] || [];\r\n      events[event] = current.concat(handler);\r\n      subject.events = events;\r\n    },\r\n    triggerHandler: function triggerHandler(event, args) {\r\n      var _this = this;\r\n\r\n      var handlers = events[event] || [];\r\n      handlers.forEach(function (fn) {\r\n        if (args && args[0] && args[0].type === undefined) {\r\n          args = [{\r\n            type: event\r\n          }].concat(args || []);\r\n        } else {\r\n          args = args || [];\r\n        }\r\n\r\n        fn.apply(_this, args);\r\n      });\r\n    }\r\n  };\r\n};\r\n\r\nvar xhr = function xhr() {\r\n  try {\r\n    return new window.XMLHttpRequest();\r\n  } catch (e) {}\r\n};\r\n\r\nvar ajax = function ajax(options) {\r\n  var request = xhr();\r\n\r\n  if (options.xhrFields && options.xhrFields.withCredentials) {\r\n    request.withCredentials = true;\r\n  }\r\n\r\n  request.onreadystatechange = function () {\r\n    if (request.readyState !== 4) {\r\n      return;\r\n    }\r\n\r\n    if (request.status === 200 && !request._hasError) {\r\n      try {\r\n        options.success && options.success(JSON.parse(request.responseText));\r\n      } catch (e) {\r\n        options.error && options.error(request);\r\n      }\r\n    } else {\r\n      options.error && options.error(request);\r\n    }\r\n  };\r\n\r\n  request.withCredentials = options.xhrFields.withCredentials;\r\n  var cacheBuster = \"_=\" + new Date().getTime();\r\n  if (options.url.indexOf(\"?\") === -1) {\r\n\t\toptions.url += \"?\" + cacheBuster;\r\n\t} else if (options.url.indexOf(\"_=\") === -1) {\r\n    options.url += \"&\" + cacheBuster;\r\n  } else {\r\n    options.url = options.url.replace(/_=\\d+/, cacheBuster);\r\n  }\r\n  request.open(options.type, options.url);\r\n  request.setRequestHeader('content-type', options.contentType);\r\n  if (options.headers) {\r\n    Object.keys(options.headers).forEach(function (key) {\r\n      var value = options.headers[key];\r\n      request.setRequestHeader(key, value);\r\n    });\r\n  }\r\n\r\n  request.send(options.data.data && 'data=' + encodeURIComponent(options.data.data));\r\n\r\n  return {\r\n    abort: function abort(reason) {\r\n      return request.abort(reason);\r\n    }\r\n  };\r\n};\r\n\r\nmodule.exports = jQueryDeferred.extend(jqueryFunction, jQueryDeferred, {\r\n  defaultAjaxHeaders: null,\r\n  ajax: ajax,\r\n  inArray: function inArray(arr, item) {\r\n    return arr.indexOf(item) !== -1;\r\n  },\r\n  trim: function trim(str) {\r\n    return str && str.trim();\r\n  },\r\n  isEmptyObject: function isEmptyObject(obj) {\r\n    return !obj || Object.keys(obj).length === 0;\r\n  },\r\n  makeArray: function makeArray(arr) {\r\n    return [].slice.call(arr, 0);\r\n  },\r\n  param: function param(obj) {\r\n    return jQueryParam(obj);\r\n  },\r\n  support: {\r\n    cors: function () {\r\n      var xhrObj = xhr();\r\n      return !!xhrObj && \"withCredentials\" in xhrObj;\r\n    }()\r\n  }\r\n});","'use strict';\r\n\r\nObject.defineProperty(exports, \"__esModule\", {\r\n    value: true\r\n});\r\n\r\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\r\n\r\nvar jQueryShim = require('./jQueryShim');\r\n\r\n/* jquery.signalR.core.js */\r\n/*global window:false */\r\n/*!\r\n * ASP.NET SignalR JavaScript Library 2.4.1\r\n * http://signalr.net/\r\n *\r\n * Copyright (c) .NET Foundation. All rights reserved.\r\n * Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n *\r\n */\r\n\r\n/// <reference path=\"Scripts/jquery-1.6.4.js\" />\r\n/// <reference path=\"jquery.signalR.version.js\" />\r\n(function ($, window, undefined) {\r\n\r\n    var resources = {\r\n        nojQuery: \"jQuery was not found. Please ensure jQuery is referenced before the SignalR client JavaScript file.\",\r\n        noTransportOnInit: \"No transport could be initialized successfully. Try specifying a different transport or none at all for auto initialization.\",\r\n        errorOnNegotiate: \"Error during negotiation request.\",\r\n        stoppedWhileLoading: \"The connection was stopped during page load.\",\r\n        stoppedWhileNegotiating: \"The connection was stopped during the negotiate request.\",\r\n        errorParsingNegotiateResponse: \"Error parsing negotiate response.\",\r\n        errorRedirectionExceedsLimit: \"Negotiate redirection limit exceeded.\",\r\n        errorDuringStartRequest: \"Error during start request. Stopping the connection.\",\r\n        errorFromServer: \"Error message received from the server: '{0}'.\",\r\n        stoppedDuringStartRequest: \"The connection was stopped during the start request.\",\r\n        errorParsingStartResponse: \"Error parsing start response: '{0}'. Stopping the connection.\",\r\n        invalidStartResponse: \"Invalid start response: '{0}'. Stopping the connection.\",\r\n        protocolIncompatible: \"You are using a version of the client that isn't compatible with the server. Client version {0}, server version {1}.\",\r\n        aspnetCoreSignalrServer: \"Detected a connection attempt to an ASP.NET Core SignalR Server. This client only supports connecting to an ASP.NET SignalR Server. See https://aka.ms/signalr-core-differences for details.\",\r\n        sendFailed: \"Send failed.\",\r\n        parseFailed: \"Failed at parsing response: {0}\",\r\n        longPollFailed: \"Long polling request failed.\",\r\n        eventSourceFailedToConnect: \"EventSource failed to connect.\",\r\n        eventSourceError: \"Error raised by EventSource\",\r\n        webSocketClosed: \"WebSocket closed.\",\r\n        pingServerFailedInvalidResponse: \"Invalid ping response when pinging server: '{0}'.\",\r\n        pingServerFailed: \"Failed to ping server.\",\r\n        pingServerFailedStatusCode: \"Failed to ping server.  Server responded with status code {0}, stopping the connection.\",\r\n        pingServerFailedParse: \"Failed to parse ping server response, stopping the connection.\",\r\n        noConnectionTransport: \"Connection is in an invalid state, there is no transport active.\",\r\n        webSocketsInvalidState: \"The Web Socket transport is in an invalid state, transitioning into reconnecting.\",\r\n        reconnectTimeout: \"Couldn't reconnect within the configured timeout of {0} ms, disconnecting.\",\r\n        reconnectWindowTimeout: \"The client has been inactive since {0} and it has exceeded the inactivity timeout of {1} ms. Stopping the connection.\",\r\n        jsonpNotSupportedWithAccessToken: \"The JSONP protocol does not support connections that require a Bearer token to connect, such as the Azure SignalR Service.\"\r\n    };\r\n\r\n    if (typeof $ !== \"function\") {\r\n        // no jQuery!\r\n        throw new Error(resources.nojQuery);\r\n    }\r\n\r\n    var _signalR,\r\n        _connection,\r\n        _pageLoaded = window.document.readyState === \"complete\",\r\n        _pageWindow = $(window),\r\n        _negotiateAbortText = \"__Negotiate Aborted__\",\r\n        events = {\r\n        onStart: \"onStart\",\r\n        onStarting: \"onStarting\",\r\n        onReceived: \"onReceived\",\r\n        onError: \"onError\",\r\n        onConnectionSlow: \"onConnectionSlow\",\r\n        onReconnecting: \"onReconnecting\",\r\n        onReconnect: \"onReconnect\",\r\n        onStateChanged: \"onStateChanged\",\r\n        onDisconnect: \"onDisconnect\"\r\n    },\r\n        ajaxDefaults = {\r\n        processData: true,\r\n        timeout: null,\r\n        async: true,\r\n        global: false,\r\n        cache: false\r\n    },\r\n        _log = function _log(msg, logging) {\r\n        if (logging === false) {\r\n            return;\r\n        }\r\n        var m;\r\n        if (typeof window.console === \"undefined\") {\r\n            return;\r\n        }\r\n        m = \"[\" + new Date().toTimeString() + \"] SignalR: \" + msg;\r\n        if (window.console.debug) {\r\n            window.console.debug(m);\r\n        } else if (window.console.log) {\r\n            window.console.log(m);\r\n        }\r\n    },\r\n        changeState = function changeState(connection, expectedState, newState) {\r\n        if (expectedState === connection.state) {\r\n            connection.state = newState;\r\n\r\n            $(connection).triggerHandler(events.onStateChanged, [{ oldState: expectedState, newState: newState }]);\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n        isDisconnecting = function isDisconnecting(connection) {\r\n        return connection.state === _signalR.connectionState.disconnected;\r\n    },\r\n        supportsKeepAlive = function supportsKeepAlive(connection) {\r\n        return connection._.keepAliveData.activated && connection.transport.supportsKeepAlive(connection);\r\n    },\r\n        configureStopReconnectingTimeout = function configureStopReconnectingTimeout(connection) {\r\n        var stopReconnectingTimeout, onReconnectTimeout;\r\n\r\n        // Check if this connection has already been configured to stop reconnecting after a specified timeout.\r\n        // Without this check if a connection is stopped then started events will be bound multiple times.\r\n        if (!connection._.configuredStopReconnectingTimeout) {\r\n            onReconnectTimeout = function onReconnectTimeout(connection) {\r\n                var message = _signalR._.format(_signalR.resources.reconnectTimeout, connection.disconnectTimeout);\r\n                connection.log(message);\r\n                $(connection).triggerHandler(events.onError, [_signalR._.error(message, /* source */\"TimeoutException\")]);\r\n                connection.stop( /* async */false, /* notifyServer */false);\r\n            };\r\n\r\n            connection.reconnecting(function () {\r\n                var connection = this;\r\n\r\n                // Guard against state changing in a previous user defined even handler\r\n                if (connection.state === _signalR.connectionState.reconnecting) {\r\n                    stopReconnectingTimeout = window.setTimeout(function () {\r\n                        onReconnectTimeout(connection);\r\n                    }, connection.disconnectTimeout);\r\n                }\r\n            });\r\n\r\n            connection.stateChanged(function (data) {\r\n                if (data.oldState === _signalR.connectionState.reconnecting) {\r\n                    // Clear the pending reconnect timeout check\r\n                    window.clearTimeout(stopReconnectingTimeout);\r\n                }\r\n            });\r\n\r\n            connection._.configuredStopReconnectingTimeout = true;\r\n        }\r\n    };\r\n\r\n    _signalR = function signalR(url, qs, logging) {\r\n        /// <summary>Creates a new SignalR connection for the given url</summary>\r\n        /// <param name=\"url\" type=\"String\">The URL of the long polling endpoint</param>\r\n        /// <param name=\"qs\" type=\"Object\">\r\n        ///     [Optional] Custom querystring parameters to add to the connection URL.\r\n        ///     If an object, every non-function member will be added to the querystring.\r\n        ///     If a string, it's added to the QS as specified.\r\n        /// </param>\r\n        /// <param name=\"logging\" type=\"Boolean\">\r\n        ///     [Optional] A flag indicating whether connection logging is enabled to the browser\r\n        ///     console/log. Defaults to false.\r\n        /// </param>\r\n\r\n        return new _signalR.fn.init(url, qs, logging);\r\n    };\r\n\r\n    _signalR._ = {\r\n        defaultContentType: \"application/x-www-form-urlencoded; charset=UTF-8\",\r\n\r\n        ieVersion: function () {\r\n            var version, matches;\r\n\r\n            if (window.navigator.appName === 'Microsoft Internet Explorer') {\r\n                // Check if the user agent has the pattern \"MSIE (one or more numbers).(one or more numbers)\";\r\n                matches = /MSIE ([0-9]+\\.[0-9]+)/.exec(window.navigator.userAgent);\r\n\r\n                if (matches) {\r\n                    version = window.parseFloat(matches[1]);\r\n                }\r\n            }\r\n\r\n            // undefined value means not IE\r\n            return version;\r\n        }(),\r\n\r\n        error: function error(message, source, context) {\r\n            var e = new Error(message);\r\n            e.source = source;\r\n\r\n            if (typeof context !== \"undefined\") {\r\n                e.context = context;\r\n            }\r\n\r\n            return e;\r\n        },\r\n\r\n        transportError: function transportError(message, transport, source, context) {\r\n            var e = this.error(message, source, context);\r\n            e.transport = transport ? transport.name : undefined;\r\n            return e;\r\n        },\r\n\r\n        format: function format() {\r\n            /// <summary>Usage: format(\"Hi {0}, you are {1}!\", \"Foo\", 100) </summary>\r\n            var s = arguments[0];\r\n            for (var i = 0; i < arguments.length - 1; i++) {\r\n                s = s.replace(\"{\" + i + \"}\", arguments[i + 1]);\r\n            }\r\n            return s;\r\n        },\r\n\r\n        firefoxMajorVersion: function firefoxMajorVersion(userAgent) {\r\n            // Firefox user agents: http://useragentstring.com/pages/Firefox/\r\n            var matches = userAgent.match(/Firefox\\/(\\d+)/);\r\n            if (!matches || !matches.length || matches.length < 2) {\r\n                return 0;\r\n            }\r\n            return parseInt(matches[1], 10 /* radix */);\r\n        },\r\n\r\n        configurePingInterval: function configurePingInterval(connection) {\r\n            var config = connection._.config,\r\n                onFail = function onFail(error) {\r\n                $(connection).triggerHandler(events.onError, [error]);\r\n            };\r\n\r\n            if (config && !connection._.pingIntervalId && config.pingInterval) {\r\n                connection._.pingIntervalId = window.setInterval(function () {\r\n                    _signalR.transports._logic.pingServer(connection).fail(onFail);\r\n                }, config.pingInterval);\r\n            }\r\n        }\r\n    };\r\n\r\n    _signalR.events = events;\r\n\r\n    _signalR.resources = resources;\r\n\r\n    _signalR.ajaxDefaults = ajaxDefaults;\r\n\r\n    _signalR.changeState = changeState;\r\n\r\n    _signalR.isDisconnecting = isDisconnecting;\r\n\r\n    _signalR.connectionState = {\r\n        connecting: 0,\r\n        connected: 1,\r\n        reconnecting: 2,\r\n        disconnected: 4\r\n    };\r\n\r\n    _signalR.hub = {\r\n        start: function start() {\r\n            // This will get replaced with the real hub connection start method when hubs is referenced correctly\r\n            throw new Error(\"SignalR: Error loading hubs. Ensure your hubs reference is correct, e.g. <script src='/signalr/js'></script>.\");\r\n        }\r\n    };\r\n\r\n    // .on() was added in version 1.7.0, .load() was removed in version 3.0.0 so we fallback to .load() if .on() does\r\n    // not exist to not break existing applications\r\n    if (typeof _pageWindow.on == \"function\") {\r\n        _pageWindow.on(\"load\", function () {\r\n            _pageLoaded = true;\r\n        });\r\n    } else {\r\n        _pageWindow.load(function () {\r\n            _pageLoaded = true;\r\n        });\r\n    }\r\n\r\n    function validateTransport(requestedTransport, connection) {\r\n        /// <summary>Validates the requested transport by cross checking it with the pre-defined signalR.transports</summary>\r\n        /// <param name=\"requestedTransport\" type=\"Object\">The designated transports that the user has specified.</param>\r\n        /// <param name=\"connection\" type=\"signalR\">The connection that will be using the requested transports.  Used for logging purposes.</param>\r\n        /// <returns type=\"Object\" />\r\n\r\n        if ($.isArray(requestedTransport)) {\r\n            // Go through transport array and remove an \"invalid\" tranports\r\n            for (var i = requestedTransport.length - 1; i >= 0; i--) {\r\n                var transport = requestedTransport[i];\r\n                if ($.type(transport) !== \"string\" || !_signalR.transports[transport]) {\r\n                    connection.log(\"Invalid transport: \" + transport + \", removing it from the transports list.\");\r\n                    requestedTransport.splice(i, 1);\r\n                }\r\n            }\r\n\r\n            // Verify we still have transports left, if we dont then we have invalid transports\r\n            if (requestedTransport.length === 0) {\r\n                connection.log(\"No transports remain within the specified transport array.\");\r\n                requestedTransport = null;\r\n            }\r\n        } else if (!_signalR.transports[requestedTransport] && requestedTransport !== \"auto\") {\r\n            connection.log(\"Invalid transport: \" + requestedTransport.toString() + \".\");\r\n            requestedTransport = null;\r\n        } else if (requestedTransport === \"auto\" && _signalR._.ieVersion <= 8) {\r\n            // If we're doing an auto transport and we're IE8 then force longPolling, #1764\r\n            return [\"longPolling\"];\r\n        }\r\n\r\n        return requestedTransport;\r\n    }\r\n\r\n    function getDefaultPort(protocol) {\r\n        if (protocol === \"http:\") {\r\n            return 80;\r\n        } else if (protocol === \"https:\") {\r\n            return 443;\r\n        }\r\n    }\r\n\r\n    function addDefaultPort(protocol, url) {\r\n        // Remove ports  from url.  We have to check if there's a / or end of line\r\n        // following the port in order to avoid removing ports such as 8080.\r\n        if (url.match(/:\\d+$/)) {\r\n            return url;\r\n        } else {\r\n            return url + \":\" + getDefaultPort(protocol);\r\n        }\r\n    }\r\n\r\n    function ConnectingMessageBuffer(connection, drainCallback) {\r\n        var that = this,\r\n            buffer = [];\r\n\r\n        that.tryBuffer = function (message) {\r\n            if (connection.state === $.signalR.connectionState.connecting) {\r\n                buffer.push(message);\r\n\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        };\r\n\r\n        that.drain = function () {\r\n            // Ensure that the connection is connected when we drain (do not want to drain while a connection is not active)\r\n            if (connection.state === $.signalR.connectionState.connected) {\r\n                while (buffer.length > 0) {\r\n                    drainCallback(buffer.shift());\r\n                }\r\n            }\r\n        };\r\n\r\n        that.clear = function () {\r\n            buffer = [];\r\n        };\r\n    }\r\n\r\n    _signalR.fn = _signalR.prototype = {\r\n        init: function init(url, qs, logging) {\r\n            var $connection = $(this);\r\n\r\n            this.url = url;\r\n            this.qs = qs;\r\n            this.lastError = null;\r\n            this._ = {\r\n                keepAliveData: {},\r\n                connectingMessageBuffer: new ConnectingMessageBuffer(this, function (message) {\r\n                    $connection.triggerHandler(events.onReceived, [message]);\r\n                }),\r\n                lastMessageAt: new Date().getTime(),\r\n                lastActiveAt: new Date().getTime(),\r\n                beatInterval: 5000, // Default value, will only be overridden if keep alive is enabled,\r\n                beatHandle: null,\r\n                totalTransportConnectTimeout: 0, // This will be the sum of the TransportConnectTimeout sent in response to negotiate and connection.transportConnectTimeout\r\n                redirectQs: null\r\n            };\r\n            if (typeof logging === \"boolean\") {\r\n                this.logging = logging;\r\n            }\r\n        },\r\n\r\n        _parseResponse: function _parseResponse(response) {\r\n            var that = this;\r\n\r\n            if (!response) {\r\n                return response;\r\n            } else if (typeof response === \"string\") {\r\n                return that.json.parse(response);\r\n            } else {\r\n                return response;\r\n            }\r\n        },\r\n\r\n        _originalJson: window.JSON,\r\n\r\n        json: window.JSON,\r\n\r\n        isCrossDomain: function isCrossDomain(url, against) {\r\n            /// <summary>Checks if url is cross domain</summary>\r\n            /// <param name=\"url\" type=\"String\">The base URL</param>\r\n            /// <param name=\"against\" type=\"Object\">\r\n            ///     An optional argument to compare the URL against, if not specified it will be set to window.location.\r\n            ///     If specified it must contain a protocol and a host property.\r\n            /// </param>\r\n            var link;\r\n\r\n            url = $.trim(url);\r\n\r\n            against = against || window.location;\r\n\r\n            if (url.indexOf(\"http\") !== 0) {\r\n                return false;\r\n            }\r\n\r\n            // Create an anchor tag.\r\n            link = window.document.createElement(\"a\");\r\n            link.href = url;\r\n\r\n            // When checking for cross domain we have to special case port 80 because the window.location will remove the\r\n            return link.protocol + addDefaultPort(link.protocol, link.host) !== against.protocol + addDefaultPort(against.protocol, against.host);\r\n        },\r\n\r\n        ajaxDataType: \"text\",\r\n\r\n        contentType: \"application/json; charset=UTF-8\",\r\n\r\n        logging: false,\r\n\r\n        state: _signalR.connectionState.disconnected,\r\n\r\n        clientProtocol: \"2.1\",\r\n\r\n        // We want to support older servers since the 2.0 change is to support redirection results, which isn't\r\n        // really breaking in the protocol. So if a user updates their client to 2.0 protocol version there's\r\n        // no reason they can't still connect to a 1.5 server. The 2.1 protocol is sent by the client so the SignalR\r\n        // service knows the client will use they query string returned via the RedirectUrl for subsequent requests.\r\n        // It doesn't matter whether the server reflects back 2.1 or continues using 2.0 as the protocol version.\r\n        supportedProtocols: [\"1.5\", \"2.0\", \"2.1\"],\r\n\r\n        negotiateRedirectSupportedProtocols: [\"2.0\", \"2.1\"],\r\n\r\n        reconnectDelay: 2000,\r\n\r\n        transportConnectTimeout: 0,\r\n\r\n        disconnectTimeout: 30000, // This should be set by the server in response to the negotiate request (30s default)\r\n\r\n        reconnectWindow: 30000, // This should be set by the server in response to the negotiate request\r\n\r\n        keepAliveWarnAt: 2 / 3, // Warn user of slow connection if we breach the X% mark of the keep alive timeout\r\n\r\n        start: function start(options, callback) {\r\n            /// <summary>Starts the connection</summary>\r\n            /// <param name=\"options\" type=\"Object\">Options map</param>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection has started</param>\r\n            var connection = this,\r\n                config = {\r\n                pingInterval: 300000,\r\n                waitForPageLoad: true,\r\n                transport: \"auto\",\r\n                jsonp: false\r\n            },\r\n                _initialize,\r\n                deferred = connection._deferral || $.Deferred(),\r\n                // Check to see if there is a pre-existing deferral that's being built on, if so we want to keep using it\r\n            parser = window.document.createElement(\"a\"),\r\n                setConnectionUrl = function setConnectionUrl(connection, url) {\r\n                if (connection.url === url && connection.baseUrl) {\r\n                    // when the url related properties are already set\r\n                    return;\r\n                }\r\n\r\n                connection.url = url;\r\n\r\n                // Resolve the full url\r\n                parser.href = connection.url;\r\n                if (!parser.protocol || parser.protocol === \":\") {\r\n                    connection.protocol = window.document.location.protocol;\r\n                    connection.host = parser.host || window.document.location.host;\r\n                } else {\r\n                    connection.protocol = parser.protocol;\r\n                    connection.host = parser.host;\r\n                }\r\n\r\n                connection.baseUrl = connection.protocol + \"//\" + connection.host;\r\n\r\n                // Set the websocket protocol\r\n                connection.wsProtocol = connection.protocol === \"https:\" ? \"wss://\" : \"ws://\";\r\n\r\n                // If the url is protocol relative, prepend the current windows protocol to the url.\r\n                if (connection.url.indexOf(\"//\") === 0) {\r\n                    connection.url = window.location.protocol + connection.url;\r\n                    connection.log(\"Protocol relative URL detected, normalizing it to '\" + connection.url + \"'.\");\r\n                }\r\n\r\n                if (connection.isCrossDomain(connection.url)) {\r\n                    connection.log(\"Auto detected cross domain url.\");\r\n\r\n                    if (config.transport === \"auto\") {\r\n                        // Cross-domain does not support foreverFrame\r\n                        config.transport = [\"webSockets\", \"serverSentEvents\", \"longPolling\"];\r\n                    }\r\n\r\n                    if (typeof connection.withCredentials === \"undefined\") {\r\n                        connection.withCredentials = true;\r\n                    }\r\n\r\n                    // Determine if jsonp is the only choice for negotiation, ajaxSend and ajaxAbort.\r\n                    // i.e. if the browser doesn't supports CORS\r\n                    // If it is, ignore any preference to the contrary, and switch to jsonp.\r\n                    if (!$.support.cors) {\r\n                        connection.ajaxDataType = \"jsonp\";\r\n                        connection.log(\"Using jsonp because this browser doesn't support CORS.\");\r\n                    }\r\n\r\n                    connection.contentType = _signalR._.defaultContentType;\r\n                }\r\n            };\r\n\r\n            connection.lastError = null;\r\n\r\n            // Persist the deferral so that if start is called multiple times the same deferral is used.\r\n            connection._deferral = deferred;\r\n\r\n            if (!connection.json) {\r\n                // no JSON!\r\n                throw new Error(\"SignalR: No JSON parser found. Please ensure json2.js is referenced before the SignalR.js file if you need to support clients without native JSON parsing support, e.g. IE<8.\");\r\n            }\r\n\r\n            if ($.type(options) === \"function\") {\r\n                // Support calling with single callback parameter\r\n                callback = options;\r\n            } else if ($.type(options) === \"object\") {\r\n                $.extend(config, options);\r\n                if ($.type(config.callback) === \"function\") {\r\n                    callback = config.callback;\r\n                }\r\n            }\r\n\r\n            config.transport = validateTransport(config.transport, connection);\r\n\r\n            // If the transport is invalid throw an error and abort start\r\n            if (!config.transport) {\r\n                throw new Error(\"SignalR: Invalid transport(s) specified, aborting start.\");\r\n            }\r\n\r\n            connection._.config = config;\r\n\r\n            // Check to see if start is being called prior to page load\r\n            // If waitForPageLoad is true we then want to re-direct function call to the window load event\r\n            if (!_pageLoaded && config.waitForPageLoad === true) {\r\n                connection._.deferredStartHandler = function () {\r\n                    connection.start(options, callback);\r\n                };\r\n                _pageWindow.bind(\"load\", connection._.deferredStartHandler);\r\n\r\n                return deferred.promise();\r\n            }\r\n\r\n            // If we're already connecting just return the same deferral as the original connection start\r\n            if (connection.state === _signalR.connectionState.connecting) {\r\n                return deferred.promise();\r\n            } else if (changeState(connection, _signalR.connectionState.disconnected, _signalR.connectionState.connecting) === false) {\r\n                // We're not connecting so try and transition into connecting.\r\n                // If we fail to transition then we're either in connected or reconnecting.\r\n\r\n                deferred.resolve(connection);\r\n                return deferred.promise();\r\n            }\r\n\r\n            configureStopReconnectingTimeout(connection);\r\n\r\n            // If jsonp with no/auto transport is specified, then set the transport to long polling\r\n            // since that is the only transport for which jsonp really makes sense.\r\n            // Some developers might actually choose to specify jsonp for same origin requests\r\n            // as demonstrated by Issue #623.\r\n            if (config.transport === \"auto\" && config.jsonp === true) {\r\n                config.transport = \"longPolling\";\r\n            }\r\n\r\n            connection.withCredentials = config.withCredentials;\r\n\r\n            // Save the original url so that we can reset it when we stop and restart the connection\r\n            connection._originalUrl = connection.url;\r\n\r\n            connection.ajaxDataType = config.jsonp ? \"jsonp\" : \"text\";\r\n\r\n            setConnectionUrl(connection, connection.url);\r\n\r\n            $(connection).bind(events.onStart, function (e, data) {\r\n                if ($.type(callback) === \"function\") {\r\n                    callback.call(connection);\r\n                }\r\n                deferred.resolve(connection);\r\n            });\r\n\r\n            connection._.initHandler = _signalR.transports._logic.initHandler(connection);\r\n\r\n            _initialize = function initialize(transports, index) {\r\n                var noTransportError = _signalR._.error(resources.noTransportOnInit);\r\n\r\n                index = index || 0;\r\n                if (index >= transports.length) {\r\n                    if (index === 0) {\r\n                        connection.log(\"No transports supported by the server were selected.\");\r\n                    } else if (index === 1) {\r\n                        connection.log(\"No fallback transports were selected.\");\r\n                    } else {\r\n                        connection.log(\"Fallback transports exhausted.\");\r\n                    }\r\n\r\n                    // No transport initialized successfully\r\n                    $(connection).triggerHandler(events.onError, [noTransportError]);\r\n                    deferred.reject(noTransportError);\r\n                    // Stop the connection if it has connected and move it into the disconnected state\r\n                    connection.stop();\r\n                    return;\r\n                }\r\n\r\n                // The connection was aborted\r\n                if (connection.state === _signalR.connectionState.disconnected) {\r\n                    return;\r\n                }\r\n\r\n                var transportName = transports[index],\r\n                    transport = _signalR.transports[transportName],\r\n                    onFallback = function onFallback() {\r\n                    _initialize(transports, index + 1);\r\n                };\r\n\r\n                connection.transport = transport;\r\n\r\n                try {\r\n                    connection._.initHandler.start(transport, function () {\r\n                        // success\r\n                        // Firefox 11+ doesn't allow sync XHR withCredentials: https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest#withCredentials\r\n                        var isFirefox11OrGreater = _signalR._.firefoxMajorVersion(window.navigator.userAgent) >= 11,\r\n                            asyncAbort = true;\r\n\r\n                        connection.log(\"The start request succeeded. Transitioning to the connected state.\");\r\n\r\n                        if (supportsKeepAlive(connection)) {\r\n                            _signalR.transports._logic.monitorKeepAlive(connection);\r\n                        }\r\n\r\n                        _signalR.transports._logic.startHeartbeat(connection);\r\n\r\n                        // Used to ensure low activity clients maintain their authentication.\r\n                        // Must be configured once a transport has been decided to perform valid ping requests.\r\n                        _signalR._.configurePingInterval(connection);\r\n\r\n                        if (!changeState(connection, _signalR.connectionState.connecting, _signalR.connectionState.connected)) {\r\n                            connection.log(\"WARNING! The connection was not in the connecting state.\");\r\n                        }\r\n\r\n                        // Drain any incoming buffered messages (messages that came in prior to connect)\r\n                        connection._.connectingMessageBuffer.drain();\r\n\r\n                        $(connection).triggerHandler(events.onStart);\r\n\r\n                        // wire the stop handler for when the user leaves the page\r\n                        _pageWindow.bind(\"unload\", function () {\r\n                            connection.log(\"Window unloading, stopping the connection.\");\r\n\r\n                            connection.stop(asyncAbort);\r\n                        });\r\n\r\n                        if (isFirefox11OrGreater) {\r\n                            // Firefox does not fire cross-domain XHRs in the normal unload handler on tab close.\r\n                            // #2400\r\n                            _pageWindow.bind(\"beforeunload\", function () {\r\n                                // If connection.stop() runs runs in beforeunload and fails, it will also fail\r\n                                // in unload unless connection.stop() runs after a timeout.\r\n                                window.setTimeout(function () {\r\n                                    connection.stop(asyncAbort);\r\n                                }, 0);\r\n                            });\r\n                        }\r\n                    }, onFallback);\r\n                } catch (error) {\r\n                    connection.log(transport.name + \" transport threw '\" + error.message + \"' when attempting to start.\");\r\n                    onFallback();\r\n                }\r\n            };\r\n\r\n            var url = connection.url + \"/negotiate\",\r\n                onFailed = function onFailed(error, connection) {\r\n                var err = _signalR._.error(resources.errorOnNegotiate, error, connection._.negotiateRequest);\r\n\r\n                $(connection).triggerHandler(events.onError, err);\r\n                deferred.reject(err);\r\n                // Stop the connection if negotiate failed\r\n                connection.stop();\r\n            };\r\n\r\n            $(connection).triggerHandler(events.onStarting);\r\n\r\n            url = _signalR.transports._logic.prepareQueryString(connection, url);\r\n\r\n            connection.log(\"Negotiating with '\" + url + \"'.\");\r\n\r\n            // Save the ajax negotiate request object so we can abort it if stop is called while the request is in flight.\r\n            connection._.negotiateRequest = function () {\r\n                var res,\r\n                    redirects = 0,\r\n                    MAX_REDIRECTS = 100,\r\n                    keepAliveData,\r\n                    protocolError,\r\n                    transports = [],\r\n                    supportedTransports = [],\r\n                    negotiate = function negotiate(connection, onSuccess) {\r\n                    var url = _signalR.transports._logic.prepareQueryString(connection, connection.url + \"/negotiate\");\r\n                    connection.log(\"Negotiating with '\" + url + \"'.\");\r\n                    var options = {\r\n                        url: url,\r\n                        error: function error(_error, statusText) {\r\n                            // We don't want to cause any errors if we're aborting our own negotiate request.\r\n                            if (statusText !== _negotiateAbortText) {\r\n                                onFailed(_error, connection);\r\n                            } else {\r\n                                // This rejection will noop if the deferred has already been resolved or rejected.\r\n                                deferred.reject(_signalR._.error(resources.stoppedWhileNegotiating, null /* error */, connection._.negotiateRequest));\r\n                            }\r\n                        },\r\n                        success: onSuccess\r\n                    };\r\n\r\n                    if (connection.accessToken) {\r\n                        options.headers = { \"Authorization\": \"Bearer \" + connection.accessToken };\r\n                    }\r\n\r\n                    return _signalR.transports._logic.ajax(connection, options);\r\n                },\r\n                    callback = function callback(result) {\r\n                    try {\r\n                        res = connection._parseResponse(result);\r\n                    } catch (error) {\r\n                        onFailed(_signalR._.error(resources.errorParsingNegotiateResponse, error), connection);\r\n                        return;\r\n                    }\r\n\r\n                    // Check if the server is an ASP.NET Core app\r\n                    if (res.availableTransports) {\r\n                        protocolError = _signalR._.error(resources.aspnetCoreSignalrServer);\r\n                        $(connection).triggerHandler(events.onError, [protocolError]);\r\n                        deferred.reject(protocolError);\r\n                        return;\r\n                    }\r\n\r\n                    if (!res.ProtocolVersion || connection.supportedProtocols.indexOf(res.ProtocolVersion) === -1) {\r\n                        protocolError = _signalR._.error(_signalR._.format(resources.protocolIncompatible, connection.clientProtocol, res.ProtocolVersion));\r\n                        $(connection).triggerHandler(events.onError, [protocolError]);\r\n                        deferred.reject(protocolError);\r\n\r\n                        return;\r\n                    }\r\n\r\n                    // Check for a redirect response (which must have a ProtocolVersion of 2.0 or greater)\r\n                    // ProtocolVersion 2.1 is the highest supported by the client, so we can just check for 2.0 or 2.1 for now\r\n                    // instead of trying to do proper version string comparison in JavaScript.\r\n                    if (connection.negotiateRedirectSupportedProtocols.indexOf(res.ProtocolVersion) !== -1) {\r\n                        if (res.Error) {\r\n                            protocolError = _signalR._.error(_signalR._.format(resources.errorFromServer, res.Error));\r\n                            $(connection).triggerHandler(events.onError, [protocolError]);\r\n                            deferred.reject(protocolError);\r\n                            return;\r\n                        } else if (res.RedirectUrl) {\r\n                            if (redirects === MAX_REDIRECTS) {\r\n                                onFailed(_signalR._.error(resources.errorRedirectionExceedsLimit), connection);\r\n                                return;\r\n                            }\r\n\r\n                            if (config.transport === \"auto\") {\r\n                                // Redirected connections do not support foreverFrame\r\n                                config.transport = [\"webSockets\", \"serverSentEvents\", \"longPolling\"];\r\n                            }\r\n\r\n                            connection.log(\"Received redirect to: \" + res.RedirectUrl);\r\n                            connection.accessToken = res.AccessToken;\r\n\r\n                            var splitUrlAndQs = res.RedirectUrl.split(\"?\", 2);\r\n                            setConnectionUrl(connection, splitUrlAndQs[0]);\r\n\r\n                            // Update redirectQs with query string from only the most recent RedirectUrl.\r\n                            connection._.redirectQs = splitUrlAndQs.length === 2 ? splitUrlAndQs[1] : null;\r\n\r\n                            if (connection.ajaxDataType === \"jsonp\" && connection.accessToken) {\r\n                                onFailed(_signalR._.error(resources.jsonpNotSupportedWithAccessToken), connection);\r\n                                return;\r\n                            }\r\n\r\n                            redirects++;\r\n                            negotiate(connection, callback);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    keepAliveData = connection._.keepAliveData;\r\n                    connection.appRelativeUrl = res.Url;\r\n                    connection.id = res.ConnectionId;\r\n                    connection.token = res.ConnectionToken;\r\n                    connection.webSocketServerUrl = res.WebSocketServerUrl;\r\n\r\n                    // The long poll timeout is the ConnectionTimeout plus 10 seconds\r\n                    connection._.pollTimeout = res.ConnectionTimeout * 1000 + 10000; // in ms\r\n\r\n                    // Once the server has labeled the PersistentConnection as Disconnected, we should stop attempting to reconnect\r\n                    // after res.DisconnectTimeout seconds.\r\n                    connection.disconnectTimeout = res.DisconnectTimeout * 1000; // in ms\r\n\r\n                    // Add the TransportConnectTimeout from the response to the transportConnectTimeout from the client to calculate the total timeout\r\n                    connection._.totalTransportConnectTimeout = connection.transportConnectTimeout + res.TransportConnectTimeout * 1000;\r\n\r\n                    // If we have a keep alive\r\n                    if (res.KeepAliveTimeout) {\r\n                        // Register the keep alive data as activated\r\n                        keepAliveData.activated = true;\r\n\r\n                        // Timeout to designate when to force the connection into reconnecting converted to milliseconds\r\n                        keepAliveData.timeout = res.KeepAliveTimeout * 1000;\r\n\r\n                        // Timeout to designate when to warn the developer that the connection may be dead or is not responding.\r\n                        keepAliveData.timeoutWarning = keepAliveData.timeout * connection.keepAliveWarnAt;\r\n\r\n                        // Instantiate the frequency in which we check the keep alive.  It must be short in order to not miss/pick up any changes\r\n                        connection._.beatInterval = (keepAliveData.timeout - keepAliveData.timeoutWarning) / 3;\r\n                    } else {\r\n                        keepAliveData.activated = false;\r\n                    }\r\n\r\n                    connection.reconnectWindow = connection.disconnectTimeout + (keepAliveData.timeout || 0);\r\n\r\n                    $.each(_signalR.transports, function (key) {\r\n                        if (key.indexOf(\"_\") === 0 || key === \"webSockets\" && !res.TryWebSockets) {\r\n                            return true;\r\n                        }\r\n                        supportedTransports.push(key);\r\n                    });\r\n\r\n                    if ($.isArray(config.transport)) {\r\n                        $.each(config.transport, function (_, transport) {\r\n                            if ($.inArray(transport, supportedTransports) >= 0) {\r\n                                transports.push(transport);\r\n                            }\r\n                        });\r\n                    } else if (config.transport === \"auto\") {\r\n                        transports = supportedTransports;\r\n                    } else if ($.inArray(config.transport, supportedTransports) >= 0) {\r\n                        transports.push(config.transport);\r\n                    }\r\n\r\n                    _initialize(transports);\r\n                };\r\n\r\n                return negotiate(connection, callback);\r\n            }();\r\n\r\n            return deferred.promise();\r\n        },\r\n\r\n        starting: function starting(callback) {\r\n            /// <summary>Adds a callback that will be invoked before anything is sent over the connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute before the connection is fully instantiated.</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onStarting, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        send: function send(data) {\r\n            /// <summary>Sends data over the connection</summary>\r\n            /// <param name=\"data\" type=\"String\">The data to send over the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n\r\n            if (connection.state === _signalR.connectionState.disconnected) {\r\n                // Connection hasn't been started yet\r\n                throw new Error(\"SignalR: Connection must be started before data can be sent. Call .start() before .send()\");\r\n            }\r\n\r\n            if (connection.state === _signalR.connectionState.connecting) {\r\n                // Connection hasn't been started yet\r\n                throw new Error(\"SignalR: Connection has not been fully initialized. Use .start().done() or .start().fail() to run logic after the connection has started.\");\r\n            }\r\n\r\n            connection.transport.send(connection, data);\r\n            // REVIEW: Should we return deferred here?\r\n            return connection;\r\n        },\r\n\r\n        received: function received(callback) {\r\n            /// <summary>Adds a callback that will be invoked after anything is received over the connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when any data is received on the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReceived, function (e, data) {\r\n                callback.call(connection, data);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        stateChanged: function stateChanged(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the connection state changes</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection state changes</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onStateChanged, function (e, data) {\r\n                callback.call(connection, data);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        error: function error(callback) {\r\n            /// <summary>Adds a callback that will be invoked after an error occurs with the connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when an error occurs on the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onError, function (e, errorData, sendData) {\r\n                connection.lastError = errorData;\r\n                // In practice 'errorData' is the SignalR built error object.\r\n                // In practice 'sendData' is undefined for all error events except those triggered by\r\n                // 'ajaxSend' and 'webSockets.send'.'sendData' is the original send payload.\r\n                callback.call(connection, errorData, sendData);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        disconnected: function disconnected(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the client disconnects</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection is broken</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onDisconnect, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        connectionSlow: function connectionSlow(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the client detects a slow connection</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection is slow</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onConnectionSlow, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n\r\n            return connection;\r\n        },\r\n\r\n        reconnecting: function reconnecting(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the underlying transport begins reconnecting</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection enters a reconnecting state</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReconnecting, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        reconnected: function reconnected(callback) {\r\n            /// <summary>Adds a callback that will be invoked when the underlying transport reconnects</summary>\r\n            /// <param name=\"callback\" type=\"Function\">A callback function to execute when the connection is restored</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this;\r\n            $(connection).bind(events.onReconnect, function (e, data) {\r\n                callback.call(connection);\r\n            });\r\n            return connection;\r\n        },\r\n\r\n        stop: function stop(async, notifyServer) {\r\n            /// <summary>Stops listening</summary>\r\n            /// <param name=\"async\" type=\"Boolean\">Whether or not to asynchronously abort the connection</param>\r\n            /// <param name=\"notifyServer\" type=\"Boolean\">Whether we want to notify the server that we are aborting the connection</param>\r\n            /// <returns type=\"signalR\" />\r\n            var connection = this,\r\n\r\n            // Save deferral because this is always cleaned up\r\n            deferral = connection._deferral;\r\n\r\n            // Verify that we've bound a load event.\r\n            if (connection._.deferredStartHandler) {\r\n                // Unbind the event.\r\n                _pageWindow.unbind(\"load\", connection._.deferredStartHandler);\r\n            }\r\n\r\n            // Always clean up private non-timeout based state.\r\n            delete connection._.config;\r\n            delete connection._.deferredStartHandler;\r\n\r\n            // This needs to be checked despite the connection state because a connection start can be deferred until page load.\r\n            // If we've deferred the start due to a page load we need to unbind the \"onLoad\" -> start event.\r\n            if (!_pageLoaded && (!connection._.config || connection._.config.waitForPageLoad === true)) {\r\n                connection.log(\"Stopping connection prior to negotiate.\");\r\n\r\n                // If we have a deferral we should reject it\r\n                if (deferral) {\r\n                    deferral.reject(_signalR._.error(resources.stoppedWhileLoading));\r\n                }\r\n\r\n                // Short-circuit because the start has not been fully started.\r\n                return;\r\n            }\r\n\r\n            if (connection.state === _signalR.connectionState.disconnected) {\r\n                return;\r\n            }\r\n\r\n            connection.log(\"Stopping connection.\");\r\n\r\n            // Clear this no matter what\r\n            window.clearTimeout(connection._.beatHandle);\r\n            window.clearInterval(connection._.pingIntervalId);\r\n\r\n            if (connection.transport) {\r\n                connection.transport.stop(connection);\r\n\r\n                if (notifyServer !== false) {\r\n                    connection.transport.abort(connection, async);\r\n                }\r\n\r\n                if (supportsKeepAlive(connection)) {\r\n                    _signalR.transports._logic.stopMonitoringKeepAlive(connection);\r\n                }\r\n\r\n                connection.transport = null;\r\n            }\r\n\r\n            if (connection._.negotiateRequest) {\r\n                // If the negotiation request has already completed this will noop.\r\n                connection._.negotiateRequest.abort(_negotiateAbortText);\r\n                delete connection._.negotiateRequest;\r\n            }\r\n\r\n            // Ensure that initHandler.stop() is called before connection._deferral is deleted\r\n            if (connection._.initHandler) {\r\n                connection._.initHandler.stop();\r\n            }\r\n\r\n            delete connection._deferral;\r\n            delete connection.messageId;\r\n            delete connection.groupsToken;\r\n            delete connection.id;\r\n            delete connection._.pingIntervalId;\r\n            delete connection._.lastMessageAt;\r\n            delete connection._.lastActiveAt;\r\n\r\n            // Clear out our message buffer\r\n            connection._.connectingMessageBuffer.clear();\r\n\r\n            // Clean up this event\r\n            $(connection).unbind(events.onStart);\r\n\r\n            // Reset the URL and clear the access token\r\n            delete connection.accessToken;\r\n            delete connection.protocol;\r\n            delete connection.host;\r\n            delete connection.baseUrl;\r\n            delete connection.wsProtocol;\r\n            delete connection.contentType;\r\n            connection.url = connection._originalUrl;\r\n            connection._.redirectQs = null;\r\n\r\n            // Trigger the disconnect event\r\n            changeState(connection, connection.state, _signalR.connectionState.disconnected);\r\n            $(connection).triggerHandler(events.onDisconnect);\r\n\r\n            return connection;\r\n        },\r\n\r\n        log: function log(msg) {\r\n            _log(msg, this.logging);\r\n        }\r\n    };\r\n\r\n    _signalR.fn.init.prototype = _signalR.fn;\r\n\r\n    _signalR.noConflict = function () {\r\n        /// <summary>Reinstates the original value of $.connection and returns the signalR object for manual assignment</summary>\r\n        /// <returns type=\"signalR\" />\r\n        if ($.connection === _signalR) {\r\n            $.connection = _connection;\r\n        }\r\n        return _signalR;\r\n    };\r\n\r\n    if ($.connection) {\r\n        _connection = $.connection;\r\n    }\r\n\r\n    $.connection = $.signalR = _signalR;\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.common.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.core.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        startAbortText = \"__Start Aborted__\",\r\n        transportLogic;\r\n\r\n    signalR.transports = {};\r\n\r\n    function beat(connection) {\r\n        if (connection._.keepAliveData.monitoring) {\r\n            checkIfAlive(connection);\r\n        }\r\n\r\n        // Ensure that we successfully marked active before continuing the heartbeat.\r\n        if (transportLogic.markActive(connection)) {\r\n            connection._.beatHandle = window.setTimeout(function () {\r\n                beat(connection);\r\n            }, connection._.beatInterval);\r\n        }\r\n    }\r\n\r\n    function checkIfAlive(connection) {\r\n        var keepAliveData = connection._.keepAliveData,\r\n            timeElapsed;\r\n\r\n        // Only check if we're connected\r\n        if (connection.state === signalR.connectionState.connected) {\r\n            timeElapsed = new Date().getTime() - connection._.lastMessageAt;\r\n\r\n            // Check if the keep alive has completely timed out\r\n            if (timeElapsed >= keepAliveData.timeout) {\r\n                connection.log(\"Keep alive timed out.  Notifying transport that connection has been lost.\");\r\n\r\n                // Notify transport that the connection has been lost\r\n                connection.transport.lostConnection(connection);\r\n            } else if (timeElapsed >= keepAliveData.timeoutWarning) {\r\n                // This is to assure that the user only gets a single warning\r\n                if (!keepAliveData.userNotified) {\r\n                    connection.log(\"Keep alive has been missed, connection may be dead/slow.\");\r\n                    $(connection).triggerHandler(events.onConnectionSlow);\r\n                    keepAliveData.userNotified = true;\r\n                }\r\n            } else {\r\n                keepAliveData.userNotified = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    function getAjaxUrl(connection, path) {\r\n        var url = connection.url + path;\r\n\r\n        if (connection.transport) {\r\n            url += \"?transport=\" + connection.transport.name;\r\n        }\r\n\r\n        return transportLogic.prepareQueryString(connection, url);\r\n    }\r\n\r\n    function InitHandler(connection) {\r\n        this.connection = connection;\r\n\r\n        this.startRequested = false;\r\n        this.startCompleted = false;\r\n        this.connectionStopped = false;\r\n    }\r\n\r\n    InitHandler.prototype = {\r\n        start: function start(transport, onSuccess, onFallback) {\r\n            var that = this,\r\n                connection = that.connection,\r\n                failCalled = false;\r\n\r\n            if (that.startRequested || that.connectionStopped) {\r\n                connection.log(\"WARNING! \" + transport.name + \" transport cannot be started. Initialization ongoing or completed.\");\r\n                return;\r\n            }\r\n\r\n            connection.log(transport.name + \" transport starting.\");\r\n\r\n            transport.start(connection, function () {\r\n                if (!failCalled) {\r\n                    that.initReceived(transport, onSuccess);\r\n                }\r\n            }, function (error) {\r\n                // Don't allow the same transport to cause onFallback to be called twice\r\n                if (!failCalled) {\r\n                    failCalled = true;\r\n                    that.transportFailed(transport, error, onFallback);\r\n                }\r\n\r\n                // Returns true if the transport should stop;\r\n                // false if it should attempt to reconnect\r\n                return !that.startCompleted || that.connectionStopped;\r\n            });\r\n\r\n            that.transportTimeoutHandle = window.setTimeout(function () {\r\n                if (!failCalled) {\r\n                    failCalled = true;\r\n                    connection.log(transport.name + \" transport timed out when trying to connect.\");\r\n                    that.transportFailed(transport, undefined, onFallback);\r\n                }\r\n            }, connection._.totalTransportConnectTimeout);\r\n        },\r\n\r\n        stop: function stop() {\r\n            this.connectionStopped = true;\r\n            window.clearTimeout(this.transportTimeoutHandle);\r\n            signalR.transports._logic.tryAbortStartRequest(this.connection);\r\n        },\r\n\r\n        initReceived: function initReceived(transport, onSuccess) {\r\n            var that = this,\r\n                connection = that.connection;\r\n\r\n            if (that.startRequested) {\r\n                connection.log(\"WARNING! The client received multiple init messages.\");\r\n                return;\r\n            }\r\n\r\n            if (that.connectionStopped) {\r\n                return;\r\n            }\r\n\r\n            that.startRequested = true;\r\n            window.clearTimeout(that.transportTimeoutHandle);\r\n\r\n            connection.log(transport.name + \" transport connected. Initiating start request.\");\r\n            signalR.transports._logic.ajaxStart(connection, function () {\r\n                that.startCompleted = true;\r\n                onSuccess();\r\n            });\r\n        },\r\n\r\n        transportFailed: function transportFailed(transport, error, onFallback) {\r\n            var connection = this.connection,\r\n                deferred = connection._deferral,\r\n                wrappedError;\r\n\r\n            if (this.connectionStopped) {\r\n                return;\r\n            }\r\n\r\n            window.clearTimeout(this.transportTimeoutHandle);\r\n\r\n            if (!this.startRequested) {\r\n                transport.stop(connection);\r\n\r\n                connection.log(transport.name + \" transport failed to connect. Attempting to fall back.\");\r\n                onFallback();\r\n            } else if (!this.startCompleted) {\r\n                // Do not attempt to fall back if a start request is ongoing during a transport failure.\r\n                // Instead, trigger an error and stop the connection.\r\n                wrappedError = signalR._.error(signalR.resources.errorDuringStartRequest, error);\r\n\r\n                connection.log(transport.name + \" transport failed during the start request. Stopping the connection.\");\r\n                $(connection).triggerHandler(events.onError, [wrappedError]);\r\n                if (deferred) {\r\n                    deferred.reject(wrappedError);\r\n                }\r\n\r\n                connection.stop();\r\n            } else {\r\n                // The start request has completed, but the connection has not stopped.\r\n                // No need to do anything here. The transport should attempt its normal reconnect logic.\r\n            }\r\n        }\r\n    };\r\n\r\n    transportLogic = signalR.transports._logic = {\r\n        ajax: function ajax(connection, options) {\r\n            return $.ajax($.extend( /*deep copy*/true, {}, $.signalR.ajaxDefaults, {\r\n                type: \"GET\",\r\n                data: {},\r\n                xhrFields: { withCredentials: connection.withCredentials },\r\n                contentType: connection.contentType,\r\n                dataType: connection.ajaxDataType\r\n            }, options));\r\n        },\r\n\r\n        pingServer: function pingServer(connection) {\r\n            /// <summary>Pings the server</summary>\r\n            /// <param name=\"connection\" type=\"signalr\">Connection associated with the server ping</param>\r\n            /// <returns type=\"signalR\" />\r\n            var url,\r\n                xhr,\r\n                deferral = $.Deferred();\r\n\r\n            if (connection.transport) {\r\n                url = connection.url + \"/ping\";\r\n\r\n                url = transportLogic.addQs(url, connection.qs);\r\n\r\n                xhr = transportLogic.ajax(connection, {\r\n                    url: url,\r\n                    headers: connection.accessToken ? { \"Authorization\": \"Bearer \" + connection.accessToken } : {},\r\n                    success: function success(result) {\r\n                        var data;\r\n\r\n                        try {\r\n                            data = connection._parseResponse(result);\r\n                        } catch (error) {\r\n                            deferral.reject(signalR._.transportError(signalR.resources.pingServerFailedParse, connection.transport, error, xhr));\r\n                            connection.stop();\r\n                            return;\r\n                        }\r\n\r\n                        if (data.Response === \"pong\") {\r\n                            deferral.resolve();\r\n                        } else {\r\n                            deferral.reject(signalR._.transportError(signalR._.format(signalR.resources.pingServerFailedInvalidResponse, result), connection.transport, null /* error */\r\n                            , xhr));\r\n                        }\r\n                    },\r\n                    error: function error(_error2) {\r\n                        if (_error2.status === 401 || _error2.status === 403) {\r\n                            deferral.reject(signalR._.transportError(signalR._.format(signalR.resources.pingServerFailedStatusCode, _error2.status), connection.transport, _error2, xhr));\r\n                            connection.stop();\r\n                        } else {\r\n                            deferral.reject(signalR._.transportError(signalR.resources.pingServerFailed, connection.transport, _error2, xhr));\r\n                        }\r\n                    }\r\n                });\r\n            } else {\r\n                deferral.reject(signalR._.transportError(signalR.resources.noConnectionTransport, connection.transport));\r\n            }\r\n\r\n            return deferral.promise();\r\n        },\r\n\r\n        prepareQueryString: function prepareQueryString(connection, url) {\r\n            var preparedUrl;\r\n\r\n            // Use addQs to start since it handles the ?/& prefix for us\r\n            preparedUrl = transportLogic.addQs(url, \"clientProtocol=\" + connection.clientProtocol);\r\n\r\n            if (typeof connection._.redirectQs === \"string\") {\r\n                // Add the redirect-specified query string params if any\r\n                preparedUrl = transportLogic.addQs(preparedUrl, connection._.redirectQs);\r\n            } else {\r\n                // Otherwise, add the user-specified query string params if any\r\n                preparedUrl = transportLogic.addQs(preparedUrl, connection.qs);\r\n            }\r\n\r\n            if (connection.token) {\r\n                preparedUrl += \"&connectionToken=\" + window.encodeURIComponent(connection.token);\r\n            }\r\n\r\n            if (connection.data) {\r\n                preparedUrl += \"&connectionData=\" + window.encodeURIComponent(connection.data);\r\n            }\r\n\r\n            return preparedUrl;\r\n        },\r\n\r\n        addQs: function addQs(url, qs) {\r\n            var appender = url.indexOf(\"?\") !== -1 ? \"&\" : \"?\",\r\n                firstChar;\r\n\r\n            if (!qs) {\r\n                return url;\r\n            }\r\n\r\n            if ((typeof qs === 'undefined' ? 'undefined' : _typeof(qs)) === \"object\") {\r\n                return url + appender + $.param(qs);\r\n            }\r\n\r\n            if (typeof qs === \"string\") {\r\n                firstChar = qs.charAt(0);\r\n\r\n                if (firstChar === \"?\" || firstChar === \"&\") {\r\n                    appender = \"\";\r\n                }\r\n\r\n                return url + appender + qs;\r\n            }\r\n\r\n            throw new Error(\"Query string property must be either a string or object.\");\r\n        },\r\n\r\n        // BUG #2953: The url needs to be same otherwise it will cause a memory leak\r\n        getUrl: function getUrl(connection, transport, reconnecting, poll, ajaxPost) {\r\n            /// <summary>Gets the url for making a GET based connect request</summary>\r\n            var baseUrl = transport === \"webSockets\" ? \"\" : connection.baseUrl,\r\n                url = baseUrl + connection.appRelativeUrl,\r\n                qs = \"transport=\" + transport;\r\n\r\n            if (!ajaxPost && connection.groupsToken) {\r\n                qs += \"&groupsToken=\" + window.encodeURIComponent(connection.groupsToken);\r\n            }\r\n\r\n            if (!reconnecting) {\r\n                url += \"/connect\";\r\n            } else {\r\n                if (poll) {\r\n                    // longPolling transport specific\r\n                    url += \"/poll\";\r\n                } else {\r\n                    url += \"/reconnect\";\r\n                }\r\n\r\n                if (!ajaxPost && connection.messageId) {\r\n                    qs += \"&messageId=\" + window.encodeURIComponent(connection.messageId);\r\n                }\r\n            }\r\n            url += \"?\" + qs;\r\n            url = transportLogic.prepareQueryString(connection, url);\r\n\r\n            // With sse or ws, access_token in request header is not supported\r\n            if (connection.transport && connection.accessToken) {\r\n                if (connection.transport.name === \"serverSentEvents\" || connection.transport.name === \"webSockets\") {\r\n                    url += \"&access_token=\" + window.encodeURIComponent(connection.accessToken);\r\n                }\r\n            }\r\n\r\n            if (!ajaxPost) {\r\n                url += \"&tid=\" + Math.floor(Math.random() * 11);\r\n            }\r\n\r\n            return url;\r\n        },\r\n\r\n        maximizePersistentResponse: function maximizePersistentResponse(minPersistentResponse) {\r\n            return {\r\n                MessageId: minPersistentResponse.C,\r\n                Messages: minPersistentResponse.M,\r\n                Initialized: typeof minPersistentResponse.S !== \"undefined\" ? true : false,\r\n                ShouldReconnect: typeof minPersistentResponse.T !== \"undefined\" ? true : false,\r\n                LongPollDelay: minPersistentResponse.L,\r\n                GroupsToken: minPersistentResponse.G,\r\n                Error: minPersistentResponse.E\r\n            };\r\n        },\r\n\r\n        updateGroups: function updateGroups(connection, groupsToken) {\r\n            if (groupsToken) {\r\n                connection.groupsToken = groupsToken;\r\n            }\r\n        },\r\n\r\n        stringifySend: function stringifySend(connection, message) {\r\n            if (typeof message === \"string\" || typeof message === \"undefined\" || message === null) {\r\n                return message;\r\n            }\r\n            return connection.json.stringify(message);\r\n        },\r\n\r\n        ajaxSend: function ajaxSend(connection, data) {\r\n            var payload = transportLogic.stringifySend(connection, data),\r\n                url = getAjaxUrl(connection, \"/send\"),\r\n                xhr,\r\n                onFail = function onFail(error, connection) {\r\n                $(connection).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.sendFailed, connection.transport, error, xhr), data]);\r\n            };\r\n\r\n            xhr = transportLogic.ajax(connection, {\r\n                url: url,\r\n                type: connection.ajaxDataType === \"jsonp\" ? \"GET\" : \"POST\",\r\n                contentType: signalR._.defaultContentType,\r\n                headers: connection.accessToken ? { \"Authorization\": \"Bearer \" + connection.accessToken } : {},\r\n                data: {\r\n                    data: payload\r\n                },\r\n                success: function success(result) {\r\n                    var res;\r\n\r\n                    if (result) {\r\n                        try {\r\n                            res = connection._parseResponse(result);\r\n                        } catch (error) {\r\n                            onFail(error, connection);\r\n                            connection.stop();\r\n                            return;\r\n                        }\r\n\r\n                        transportLogic.triggerReceived(connection, res);\r\n                    }\r\n                },\r\n                error: function error(_error3, textStatus) {\r\n                    if (textStatus === \"abort\" || textStatus === \"parsererror\") {\r\n                        // The parsererror happens for sends that don't return any data, and hence\r\n                        // don't write the jsonp callback to the response. This is harder to fix on the server\r\n                        // so just hack around it on the client for now.\r\n                        return;\r\n                    }\r\n\r\n                    onFail(_error3, connection);\r\n                }\r\n            });\r\n\r\n            return xhr;\r\n        },\r\n\r\n        ajaxAbort: function ajaxAbort(connection, async) {\r\n            if (typeof connection.transport === \"undefined\") {\r\n                return;\r\n            }\r\n\r\n            // Async by default unless explicitly overidden\r\n            async = typeof async === \"undefined\" ? true : async;\r\n\r\n            var url = getAjaxUrl(connection, \"/abort\");\r\n\r\n            transportLogic.ajax(connection, {\r\n                url: url,\r\n                async: async,\r\n                timeout: 1000,\r\n                type: \"POST\",\r\n                headers: connection.accessToken ? { \"Authorization\": \"Bearer \" + connection.accessToken } : {},\r\n                dataType: \"text\" // We don't want to use JSONP here even when JSONP is enabled\r\n            });\r\n\r\n            connection.log(\"Fired ajax abort async = \" + async + \".\");\r\n        },\r\n\r\n        ajaxStart: function ajaxStart(connection, onSuccess) {\r\n            var rejectDeferred = function rejectDeferred(error) {\r\n                var deferred = connection._deferral;\r\n                if (deferred) {\r\n                    deferred.reject(error);\r\n                }\r\n            },\r\n                triggerStartError = function triggerStartError(error) {\r\n                connection.log(\"The start request failed. Stopping the connection.\");\r\n                $(connection).triggerHandler(events.onError, [error]);\r\n                rejectDeferred(error);\r\n                connection.stop();\r\n            };\r\n\r\n            connection._.startRequest = transportLogic.ajax(connection, {\r\n                url: getAjaxUrl(connection, \"/start\"),\r\n                headers: connection.accessToken ? { \"Authorization\": \"Bearer \" + connection.accessToken } : {},\r\n                success: function success(result, statusText, xhr) {\r\n                    var data;\r\n\r\n                    try {\r\n                        data = connection._parseResponse(result);\r\n                    } catch (error) {\r\n                        triggerStartError(signalR._.error(signalR._.format(signalR.resources.errorParsingStartResponse, result), error, xhr));\r\n                        return;\r\n                    }\r\n\r\n                    if (data.Response === \"started\") {\r\n                        onSuccess();\r\n                    } else {\r\n                        triggerStartError(signalR._.error(signalR._.format(signalR.resources.invalidStartResponse, result), null /* error */, xhr));\r\n                    }\r\n                },\r\n                error: function error(xhr, statusText, _error4) {\r\n                    if (statusText !== startAbortText) {\r\n                        triggerStartError(signalR._.error(signalR.resources.errorDuringStartRequest, _error4, xhr));\r\n                    } else {\r\n                        // Stop has been called, no need to trigger the error handler\r\n                        // or stop the connection again with onStartError\r\n                        connection.log(\"The start request aborted because connection.stop() was called.\");\r\n                        rejectDeferred(signalR._.error(signalR.resources.stoppedDuringStartRequest, null /* error */, xhr));\r\n                    }\r\n                }\r\n            });\r\n        },\r\n\r\n        tryAbortStartRequest: function tryAbortStartRequest(connection) {\r\n            if (connection._.startRequest) {\r\n                // If the start request has already completed this will noop.\r\n                connection._.startRequest.abort(startAbortText);\r\n                delete connection._.startRequest;\r\n            }\r\n        },\r\n\r\n        tryInitialize: function tryInitialize(connection, persistentResponse, onInitialized) {\r\n            if (persistentResponse.Initialized && onInitialized) {\r\n                onInitialized();\r\n            } else if (persistentResponse.Initialized) {\r\n                connection.log(\"WARNING! The client received an init message after reconnecting.\");\r\n            }\r\n        },\r\n\r\n        triggerReceived: function triggerReceived(connection, data) {\r\n            if (!connection._.connectingMessageBuffer.tryBuffer(data)) {\r\n                $(connection).triggerHandler(events.onReceived, [data]);\r\n            }\r\n        },\r\n\r\n        processMessages: function processMessages(connection, minData, onInitialized) {\r\n            var data;\r\n\r\n            if (minData && typeof minData.I !== \"undefined\") {\r\n                // This is a response to a message the client sent\r\n                transportLogic.triggerReceived(connection, minData);\r\n                return;\r\n            }\r\n\r\n            // Update the last message time stamp\r\n            transportLogic.markLastMessage(connection);\r\n\r\n            if (minData) {\r\n                // This is a message send directly to the client\r\n                data = transportLogic.maximizePersistentResponse(minData);\r\n\r\n                if (data.Error) {\r\n                    // This is a global error, stop the connection.\r\n                    connection.log(\"Received an error message from the server: \" + minData.E);\r\n                    $(connection).triggerHandler(signalR.events.onError, [signalR._.error(minData.E, /* source */\"ServerError\")]);\r\n                    connection.stop( /* async */false, /* notifyServer */false);\r\n                    return;\r\n                }\r\n\r\n                transportLogic.updateGroups(connection, data.GroupsToken);\r\n\r\n                if (data.MessageId) {\r\n                    connection.messageId = data.MessageId;\r\n                }\r\n\r\n                if (data.Messages) {\r\n                    $.each(data.Messages, function (index, message) {\r\n                        transportLogic.triggerReceived(connection, message);\r\n                    });\r\n\r\n                    transportLogic.tryInitialize(connection, data, onInitialized);\r\n                }\r\n            }\r\n        },\r\n\r\n        monitorKeepAlive: function monitorKeepAlive(connection) {\r\n            var keepAliveData = connection._.keepAliveData;\r\n\r\n            // If we haven't initiated the keep alive timeouts then we need to\r\n            if (!keepAliveData.monitoring) {\r\n                keepAliveData.monitoring = true;\r\n\r\n                transportLogic.markLastMessage(connection);\r\n\r\n                // Save the function so we can unbind it on stop\r\n                connection._.keepAliveData.reconnectKeepAliveUpdate = function () {\r\n                    // Mark a new message so that keep alive doesn't time out connections\r\n                    transportLogic.markLastMessage(connection);\r\n                };\r\n\r\n                // Update Keep alive on reconnect\r\n                $(connection).bind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);\r\n\r\n                connection.log(\"Now monitoring keep alive with a warning timeout of \" + keepAliveData.timeoutWarning + \", keep alive timeout of \" + keepAliveData.timeout + \" and disconnecting timeout of \" + connection.disconnectTimeout);\r\n            } else {\r\n                connection.log(\"Tried to monitor keep alive but it's already being monitored.\");\r\n            }\r\n        },\r\n\r\n        stopMonitoringKeepAlive: function stopMonitoringKeepAlive(connection) {\r\n            var keepAliveData = connection._.keepAliveData;\r\n\r\n            // Only attempt to stop the keep alive monitoring if its being monitored\r\n            if (keepAliveData.monitoring) {\r\n                // Stop monitoring\r\n                keepAliveData.monitoring = false;\r\n\r\n                // Remove the updateKeepAlive function from the reconnect event\r\n                $(connection).unbind(events.onReconnect, connection._.keepAliveData.reconnectKeepAliveUpdate);\r\n\r\n                // Clear all the keep alive data\r\n                connection._.keepAliveData = {};\r\n                connection.log(\"Stopping the monitoring of the keep alive.\");\r\n            }\r\n        },\r\n\r\n        startHeartbeat: function startHeartbeat(connection) {\r\n            connection._.lastActiveAt = new Date().getTime();\r\n            beat(connection);\r\n        },\r\n\r\n        markLastMessage: function markLastMessage(connection) {\r\n            connection._.lastMessageAt = new Date().getTime();\r\n        },\r\n\r\n        markActive: function markActive(connection) {\r\n            if (transportLogic.verifyLastActive(connection)) {\r\n                connection._.lastActiveAt = new Date().getTime();\r\n                return true;\r\n            }\r\n\r\n            return false;\r\n        },\r\n\r\n        isConnectedOrReconnecting: function isConnectedOrReconnecting(connection) {\r\n            return connection.state === signalR.connectionState.connected || connection.state === signalR.connectionState.reconnecting;\r\n        },\r\n\r\n        ensureReconnectingState: function ensureReconnectingState(connection) {\r\n            if (changeState(connection, signalR.connectionState.connected, signalR.connectionState.reconnecting) === true) {\r\n                $(connection).triggerHandler(events.onReconnecting);\r\n            }\r\n            return connection.state === signalR.connectionState.reconnecting;\r\n        },\r\n\r\n        clearReconnectTimeout: function clearReconnectTimeout(connection) {\r\n            if (connection && connection._.reconnectTimeout) {\r\n                window.clearTimeout(connection._.reconnectTimeout);\r\n                delete connection._.reconnectTimeout;\r\n            }\r\n        },\r\n\r\n        verifyLastActive: function verifyLastActive(connection) {\r\n            if (new Date().getTime() - connection._.lastActiveAt >= connection.reconnectWindow) {\r\n                var message = signalR._.format(signalR.resources.reconnectWindowTimeout, new Date(connection._.lastActiveAt), connection.reconnectWindow);\r\n                connection.log(message);\r\n                $(connection).triggerHandler(events.onError, [signalR._.error(message, /* source */\"TimeoutException\")]);\r\n                connection.stop( /* async */false, /* notifyServer */false);\r\n                return false;\r\n            }\r\n\r\n            return true;\r\n        },\r\n\r\n        reconnect: function reconnect(connection, transportName) {\r\n            var transport = signalR.transports[transportName];\r\n\r\n            // We should only set a reconnectTimeout if we are currently connected\r\n            // and a reconnectTimeout isn't already set.\r\n            if (transportLogic.isConnectedOrReconnecting(connection) && !connection._.reconnectTimeout) {\r\n                // Need to verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.\r\n                if (!transportLogic.verifyLastActive(connection)) {\r\n                    return;\r\n                }\r\n\r\n                connection._.reconnectTimeout = window.setTimeout(function () {\r\n                    if (!transportLogic.verifyLastActive(connection)) {\r\n                        return;\r\n                    }\r\n\r\n                    transport.stop(connection);\r\n\r\n                    if (transportLogic.ensureReconnectingState(connection)) {\r\n                        connection.log(transportName + \" reconnecting.\");\r\n                        transport.start(connection);\r\n                    }\r\n                }, connection.reconnectDelay);\r\n            }\r\n        },\r\n\r\n        handleParseFailure: function handleParseFailure(connection, result, error, onFailed, context) {\r\n            var wrappedError = signalR._.transportError(signalR._.format(signalR.resources.parseFailed, result), connection.transport, error, context);\r\n\r\n            // If we're in the initialization phase trigger onFailed, otherwise stop the connection.\r\n            if (onFailed && onFailed(wrappedError)) {\r\n                connection.log(\"Failed to parse server response while attempting to connect.\");\r\n            } else {\r\n                $(connection).triggerHandler(events.onError, [wrappedError]);\r\n                connection.stop();\r\n            }\r\n        },\r\n\r\n        initHandler: function initHandler(connection) {\r\n            return new InitHandler(connection);\r\n        },\r\n\r\n        foreverFrame: {\r\n            count: 0,\r\n            connections: {}\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.webSockets.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic;\r\n\r\n    signalR.transports.webSockets = {\r\n        name: \"webSockets\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return true;\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            var payload = transportLogic.stringifySend(connection, data);\r\n\r\n            try {\r\n                connection.socket.send(payload);\r\n            } catch (ex) {\r\n                $(connection).triggerHandler(events.onError, [signalR._.transportError(signalR.resources.webSocketsInvalidState, connection.transport, ex, connection.socket), data]);\r\n            }\r\n        },\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            var url,\r\n                opened = false,\r\n                that = this,\r\n                reconnecting = !onSuccess,\r\n                $connection = $(connection);\r\n\r\n            if (!window.WebSocket) {\r\n                onFailed();\r\n                return;\r\n            }\r\n\r\n            if (!connection.socket) {\r\n                if (connection.webSocketServerUrl) {\r\n                    url = connection.webSocketServerUrl;\r\n                } else {\r\n                    url = connection.wsProtocol + connection.host;\r\n                }\r\n\r\n                url += transportLogic.getUrl(connection, this.name, reconnecting);\r\n\r\n                connection.log(\"Connecting to websocket endpoint '\" + url + \"'.\");\r\n                connection.socket = new window.WebSocket(url);\r\n\r\n                connection.socket.onopen = function () {\r\n                    opened = true;\r\n                    connection.log(\"Websocket opened.\");\r\n\r\n                    transportLogic.clearReconnectTimeout(connection);\r\n\r\n                    if (changeState(connection, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n                        $connection.triggerHandler(events.onReconnect);\r\n                    }\r\n                };\r\n\r\n                connection.socket.onclose = function (event) {\r\n                    var error;\r\n\r\n                    // Only handle a socket close if the close is from the current socket.\r\n                    // Sometimes on disconnect the server will push down an onclose event\r\n                    // to an expired socket.\r\n\r\n                    if (this === connection.socket) {\r\n                        if (opened && typeof event.wasClean !== \"undefined\" && event.wasClean === false) {\r\n                            // Ideally this would use the websocket.onerror handler (rather than checking wasClean in onclose) but\r\n                            // I found in some circumstances Chrome won't call onerror. This implementation seems to work on all browsers.\r\n                            error = signalR._.transportError(signalR.resources.webSocketClosed, connection.transport, event);\r\n\r\n                            connection.log(\"Unclean disconnect from websocket: \" + (event.reason || \"[no reason given].\"));\r\n                        } else {\r\n                            connection.log(\"Websocket closed.\");\r\n                        }\r\n\r\n                        if (!onFailed || !onFailed(error)) {\r\n                            if (error) {\r\n                                $(connection).triggerHandler(events.onError, [error]);\r\n                            }\r\n\r\n                            that.reconnect(connection);\r\n                        }\r\n                    }\r\n                };\r\n\r\n                connection.socket.onmessage = function (event) {\r\n                    var data;\r\n\r\n                    try {\r\n                        data = connection._parseResponse(event.data);\r\n                    } catch (error) {\r\n                        transportLogic.handleParseFailure(connection, event.data, error, onFailed, event);\r\n                        return;\r\n                    }\r\n\r\n                    if (data) {\r\n                        transportLogic.processMessages(connection, data, onSuccess);\r\n                    }\r\n                };\r\n            }\r\n        },\r\n\r\n        reconnect: function reconnect(connection) {\r\n            transportLogic.reconnect(connection, this.name);\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            // Don't trigger a reconnect after stopping\r\n            transportLogic.clearReconnectTimeout(connection);\r\n\r\n            if (connection.socket) {\r\n                connection.log(\"Closing the Websocket.\");\r\n                connection.socket.close();\r\n                connection.socket = null;\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.serverSentEvents.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic,\r\n        clearReconnectAttemptTimeout = function clearReconnectAttemptTimeout(connection) {\r\n        window.clearTimeout(connection._.reconnectAttemptTimeoutHandle);\r\n        delete connection._.reconnectAttemptTimeoutHandle;\r\n    };\r\n\r\n    signalR.transports.serverSentEvents = {\r\n        name: \"serverSentEvents\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return true;\r\n        },\r\n\r\n        timeOut: 3000,\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            var that = this,\r\n                opened = false,\r\n                $connection = $(connection),\r\n                reconnecting = !onSuccess,\r\n                url;\r\n\r\n            if (connection.eventSource) {\r\n                connection.log(\"The connection already has an event source. Stopping it.\");\r\n                connection.stop();\r\n            }\r\n\r\n            if (!window.EventSource) {\r\n                if (onFailed) {\r\n                    connection.log(\"This browser doesn't support SSE.\");\r\n                    onFailed();\r\n                }\r\n                return;\r\n            }\r\n\r\n            url = transportLogic.getUrl(connection, this.name, reconnecting);\r\n\r\n            try {\r\n                connection.log(\"Attempting to connect to SSE endpoint '\" + url + \"'.\");\r\n                connection.eventSource = new window.EventSource(url, { withCredentials: connection.withCredentials });\r\n            } catch (e) {\r\n                connection.log(\"EventSource failed trying to connect with error \" + e.Message + \".\");\r\n                if (onFailed) {\r\n                    // The connection failed, call the failed callback\r\n                    onFailed();\r\n                } else {\r\n                    $connection.triggerHandler(events.onError, [signalR._.transportError(signalR.resources.eventSourceFailedToConnect, connection.transport, e)]);\r\n                    if (reconnecting) {\r\n                        // If we were reconnecting, rather than doing initial connect, then try reconnect again\r\n                        that.reconnect(connection);\r\n                    }\r\n                }\r\n                return;\r\n            }\r\n\r\n            if (reconnecting) {\r\n                connection._.reconnectAttemptTimeoutHandle = window.setTimeout(function () {\r\n                    if (opened === false) {\r\n                        // If we're reconnecting and the event source is attempting to connect,\r\n                        // don't keep retrying. This causes duplicate connections to spawn.\r\n                        if (connection.eventSource.readyState !== window.EventSource.OPEN) {\r\n                            // If we were reconnecting, rather than doing initial connect, then try reconnect again\r\n                            that.reconnect(connection);\r\n                        }\r\n                    }\r\n                }, that.timeOut);\r\n            }\r\n\r\n            connection.eventSource.addEventListener(\"open\", function (e) {\r\n                connection.log(\"EventSource connected.\");\r\n\r\n                clearReconnectAttemptTimeout(connection);\r\n                transportLogic.clearReconnectTimeout(connection);\r\n\r\n                if (opened === false) {\r\n                    opened = true;\r\n\r\n                    if (changeState(connection, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n                        $connection.triggerHandler(events.onReconnect);\r\n                    }\r\n                }\r\n            }, false);\r\n\r\n            connection.eventSource.addEventListener(\"message\", function (e) {\r\n                var res;\r\n\r\n                // process messages\r\n                if (e.data === \"initialized\") {\r\n                    return;\r\n                }\r\n\r\n                try {\r\n                    res = connection._parseResponse(e.data);\r\n                } catch (error) {\r\n                    transportLogic.handleParseFailure(connection, e.data, error, onFailed, e);\r\n                    return;\r\n                }\r\n\r\n                transportLogic.processMessages(connection, res, onSuccess);\r\n            }, false);\r\n\r\n            connection.eventSource.addEventListener(\"error\", function (e) {\r\n                var error = signalR._.transportError(signalR.resources.eventSourceError, connection.transport, e);\r\n\r\n                // Only handle an error if the error is from the current Event Source.\r\n                // Sometimes on disconnect the server will push down an error event\r\n                // to an expired Event Source.\r\n                if (this !== connection.eventSource) {\r\n                    return;\r\n                }\r\n\r\n                if (onFailed && onFailed(error)) {\r\n                    return;\r\n                }\r\n\r\n                connection.log(\"EventSource readyState: \" + connection.eventSource.readyState + \".\");\r\n\r\n                if (e.eventPhase === window.EventSource.CLOSED) {\r\n                    // We don't use the EventSource's native reconnect function as it\r\n                    // doesn't allow us to change the URL when reconnecting. We need\r\n                    // to change the URL to not include the /connect suffix, and pass\r\n                    // the last message id we received.\r\n                    connection.log(\"EventSource reconnecting due to the server connection ending.\");\r\n                    that.reconnect(connection);\r\n                } else {\r\n                    // connection error\r\n                    connection.log(\"EventSource error.\");\r\n                    $connection.triggerHandler(events.onError, [error]);\r\n                }\r\n            }, false);\r\n        },\r\n\r\n        reconnect: function reconnect(connection) {\r\n            transportLogic.reconnect(connection, this.name);\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            // Don't trigger a reconnect after stopping\r\n            clearReconnectAttemptTimeout(connection);\r\n            transportLogic.clearReconnectTimeout(connection);\r\n\r\n            if (connection && connection.eventSource) {\r\n                connection.log(\"EventSource calling close().\");\r\n                connection.eventSource.close();\r\n                connection.eventSource = null;\r\n                delete connection.eventSource;\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.foreverFrame.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        transportLogic = signalR.transports._logic,\r\n        createFrame = function createFrame() {\r\n        var frame = window.document.createElement(\"iframe\");\r\n        frame.setAttribute(\"style\", \"position:absolute;top:0;left:0;width:0;height:0;visibility:hidden;\");\r\n        return frame;\r\n    },\r\n\r\n    // Used to prevent infinite loading icon spins in older versions of ie\r\n    // We build this object inside a closure so we don't pollute the rest of\r\n    // the foreverFrame transport with unnecessary functions/utilities.\r\n    loadPreventer = function () {\r\n        var loadingFixIntervalId = null,\r\n            loadingFixInterval = 1000,\r\n            attachedTo = 0;\r\n\r\n        return {\r\n            prevent: function prevent() {\r\n                // Prevent additional iframe removal procedures from newer browsers\r\n                if (signalR._.ieVersion <= 8) {\r\n                    // We only ever want to set the interval one time, so on the first attachedTo\r\n                    if (attachedTo === 0) {\r\n                        // Create and destroy iframe every 3 seconds to prevent loading icon, super hacky\r\n                        loadingFixIntervalId = window.setInterval(function () {\r\n                            var tempFrame = createFrame();\r\n\r\n                            window.document.body.appendChild(tempFrame);\r\n                            window.document.body.removeChild(tempFrame);\r\n\r\n                            tempFrame = null;\r\n                        }, loadingFixInterval);\r\n                    }\r\n\r\n                    attachedTo++;\r\n                }\r\n            },\r\n            cancel: function cancel() {\r\n                // Only clear the interval if there's only one more object that the loadPreventer is attachedTo\r\n                if (attachedTo === 1) {\r\n                    window.clearInterval(loadingFixIntervalId);\r\n                }\r\n\r\n                if (attachedTo > 0) {\r\n                    attachedTo--;\r\n                }\r\n            }\r\n        };\r\n    }();\r\n\r\n    signalR.transports.foreverFrame = {\r\n        name: \"foreverFrame\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return true;\r\n        },\r\n\r\n        // Added as a value here so we can create tests to verify functionality\r\n        iframeClearThreshold: 50,\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            if (connection.accessToken) {\r\n                if (onFailed) {\r\n                    connection.log(\"Forever Frame does not support connections that require a Bearer token to connect, such as the Azure SignalR Service.\");\r\n                    onFailed();\r\n                }\r\n                return;\r\n            }\r\n\r\n            var that = this,\r\n                frameId = transportLogic.foreverFrame.count += 1,\r\n                url,\r\n                frame = createFrame(),\r\n                frameLoadHandler = function frameLoadHandler() {\r\n                connection.log(\"Forever frame iframe finished loading and is no longer receiving messages.\");\r\n                if (!onFailed || !onFailed()) {\r\n                    that.reconnect(connection);\r\n                }\r\n            };\r\n\r\n            if (window.EventSource) {\r\n                // If the browser supports SSE, don't use Forever Frame\r\n                if (onFailed) {\r\n                    connection.log(\"Forever Frame is not supported by SignalR on browsers with SSE support.\");\r\n                    onFailed();\r\n                }\r\n                return;\r\n            }\r\n\r\n            frame.setAttribute(\"data-signalr-connection-id\", connection.id);\r\n\r\n            // Start preventing loading icon\r\n            // This will only perform work if the loadPreventer is not attached to another connection.\r\n            loadPreventer.prevent();\r\n\r\n            // Build the url\r\n            url = transportLogic.getUrl(connection, this.name);\r\n            url += \"&frameId=\" + frameId;\r\n\r\n            // add frame to the document prior to setting URL to avoid caching issues.\r\n            window.document.documentElement.appendChild(frame);\r\n\r\n            connection.log(\"Binding to iframe's load event.\");\r\n\r\n            if (frame.addEventListener) {\r\n                frame.addEventListener(\"load\", frameLoadHandler, false);\r\n            } else if (frame.attachEvent) {\r\n                frame.attachEvent(\"onload\", frameLoadHandler);\r\n            }\r\n\r\n            frame.src = url;\r\n            transportLogic.foreverFrame.connections[frameId] = connection;\r\n\r\n            connection.frame = frame;\r\n            connection.frameId = frameId;\r\n\r\n            if (onSuccess) {\r\n                connection.onSuccess = function () {\r\n                    connection.log(\"Iframe transport started.\");\r\n                    onSuccess();\r\n                };\r\n            }\r\n        },\r\n\r\n        reconnect: function reconnect(connection) {\r\n            var that = this;\r\n\r\n            // Need to verify connection state and verify before the setTimeout occurs because an application sleep could occur during the setTimeout duration.\r\n            if (transportLogic.isConnectedOrReconnecting(connection) && transportLogic.verifyLastActive(connection)) {\r\n                window.setTimeout(function () {\r\n                    // Verify that we're ok to reconnect.\r\n                    if (!transportLogic.verifyLastActive(connection)) {\r\n                        return;\r\n                    }\r\n\r\n                    if (connection.frame && transportLogic.ensureReconnectingState(connection)) {\r\n                        var frame = connection.frame,\r\n                            src = transportLogic.getUrl(connection, that.name, true) + \"&frameId=\" + connection.frameId;\r\n                        connection.log(\"Updating iframe src to '\" + src + \"'.\");\r\n                        frame.src = src;\r\n                    }\r\n                }, connection.reconnectDelay);\r\n            }\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            this.reconnect(connection);\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        receive: function receive(connection, data) {\r\n            var cw, body, response;\r\n\r\n            if (connection.json !== connection._originalJson) {\r\n                // If there's a custom JSON parser configured then serialize the object\r\n                // using the original (browser) JSON parser and then deserialize it using\r\n                // the custom parser (connection._parseResponse does that). This is so we\r\n                // can easily send the response from the server as \"raw\" JSON but still\r\n                // support custom JSON deserialization in the browser.\r\n                data = connection._originalJson.stringify(data);\r\n            }\r\n\r\n            response = connection._parseResponse(data);\r\n\r\n            transportLogic.processMessages(connection, response, connection.onSuccess);\r\n\r\n            // Protect against connection stopping from a callback trigger within the processMessages above.\r\n            if (connection.state === $.signalR.connectionState.connected) {\r\n                // Delete the script & div elements\r\n                connection.frameMessageCount = (connection.frameMessageCount || 0) + 1;\r\n                if (connection.frameMessageCount > signalR.transports.foreverFrame.iframeClearThreshold) {\r\n                    connection.frameMessageCount = 0;\r\n                    cw = connection.frame.contentWindow || connection.frame.contentDocument;\r\n                    if (cw && cw.document && cw.document.body) {\r\n                        body = cw.document.body;\r\n\r\n                        // Remove all the child elements from the iframe's body to conserver memory\r\n                        while (body.firstChild) {\r\n                            body.removeChild(body.firstChild);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            var cw = null;\r\n\r\n            // Stop attempting to prevent loading icon\r\n            loadPreventer.cancel();\r\n\r\n            if (connection.frame) {\r\n                if (connection.frame.stop) {\r\n                    connection.frame.stop();\r\n                } else {\r\n                    try {\r\n                        cw = connection.frame.contentWindow || connection.frame.contentDocument;\r\n                        if (cw.document && cw.document.execCommand) {\r\n                            cw.document.execCommand(\"Stop\");\r\n                        }\r\n                    } catch (e) {\r\n                        connection.log(\"Error occurred when stopping foreverFrame transport. Message = \" + e.message + \".\");\r\n                    }\r\n                }\r\n\r\n                // Ensure the iframe is where we left it\r\n                if (connection.frame.parentNode === window.document.documentElement) {\r\n                    window.document.documentElement.removeChild(connection.frame);\r\n                }\r\n\r\n                delete transportLogic.foreverFrame.connections[connection.frameId];\r\n                connection.frame = null;\r\n                connection.frameId = null;\r\n                delete connection.frame;\r\n                delete connection.frameId;\r\n                delete connection.onSuccess;\r\n                delete connection.frameMessageCount;\r\n                connection.log(\"Stopping forever frame.\");\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        },\r\n\r\n        getConnection: function getConnection(id) {\r\n            return transportLogic.foreverFrame.connections[id];\r\n        },\r\n\r\n        started: function started(connection) {\r\n            if (changeState(connection, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n\r\n                $(connection).triggerHandler(events.onReconnect);\r\n            }\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.transports.longPolling.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.transports.common.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var signalR = $.signalR,\r\n        events = $.signalR.events,\r\n        changeState = $.signalR.changeState,\r\n        isDisconnecting = $.signalR.isDisconnecting,\r\n        transportLogic = signalR.transports._logic;\r\n\r\n    signalR.transports.longPolling = {\r\n        name: \"longPolling\",\r\n\r\n        supportsKeepAlive: function supportsKeepAlive() {\r\n            return false;\r\n        },\r\n\r\n        reconnectDelay: 3000,\r\n\r\n        start: function start(connection, onSuccess, onFailed) {\r\n            /// <summary>Starts the long polling connection</summary>\r\n            /// <param name=\"connection\" type=\"signalR\">The SignalR connection to start</param>\r\n            var that = this,\r\n                _fireConnect = function fireConnect() {\r\n                _fireConnect = $.noop;\r\n\r\n                connection.log(\"LongPolling connected.\");\r\n\r\n                if (onSuccess) {\r\n                    onSuccess();\r\n                } else {\r\n                    connection.log(\"WARNING! The client received an init message after reconnecting.\");\r\n                }\r\n            },\r\n                tryFailConnect = function tryFailConnect(error) {\r\n                if (onFailed(error)) {\r\n                    connection.log(\"LongPolling failed to connect.\");\r\n                    return true;\r\n                }\r\n\r\n                return false;\r\n            },\r\n                privateData = connection._,\r\n                reconnectErrors = 0,\r\n                fireReconnected = function fireReconnected(instance) {\r\n                window.clearTimeout(privateData.reconnectTimeoutId);\r\n                privateData.reconnectTimeoutId = null;\r\n\r\n                if (changeState(instance, signalR.connectionState.reconnecting, signalR.connectionState.connected) === true) {\r\n                    // Successfully reconnected!\r\n                    instance.log(\"Raising the reconnect event\");\r\n                    $(instance).triggerHandler(events.onReconnect);\r\n                }\r\n            },\r\n\r\n            // 1 hour\r\n            maxFireReconnectedTimeout = 3600000;\r\n\r\n            if (connection.pollXhr) {\r\n                connection.log(\"Polling xhr requests already exists, aborting.\");\r\n                connection.stop();\r\n            }\r\n\r\n            connection.messageId = null;\r\n\r\n            privateData.reconnectTimeoutId = null;\r\n\r\n            privateData.pollTimeoutId = window.setTimeout(function () {\r\n                (function poll(instance, raiseReconnect) {\r\n                    var messageId = instance.messageId,\r\n                        connect = messageId === null,\r\n                        reconnecting = !connect,\r\n                        polling = !raiseReconnect,\r\n                        url = transportLogic.getUrl(instance, that.name, reconnecting, polling, true /* use Post for longPolling */),\r\n                        postData = {};\r\n\r\n                    if (instance.messageId) {\r\n                        postData.messageId = instance.messageId;\r\n                    }\r\n\r\n                    if (instance.groupsToken) {\r\n                        postData.groupsToken = instance.groupsToken;\r\n                    }\r\n\r\n                    // If we've disconnected during the time we've tried to re-instantiate the poll then stop.\r\n                    if (isDisconnecting(instance) === true) {\r\n                        return;\r\n                    }\r\n\r\n                    connection.log(\"Opening long polling request to '\" + url + \"'.\");\r\n                    instance.pollXhr = transportLogic.ajax(connection, {\r\n                        xhrFields: {\r\n                            onprogress: function onprogress() {\r\n                                transportLogic.markLastMessage(connection);\r\n                            }\r\n                        },\r\n                        url: url,\r\n                        type: \"POST\",\r\n                        contentType: signalR._.defaultContentType,\r\n                        data: postData,\r\n                        timeout: connection._.pollTimeout,\r\n                        headers: connection.accessToken ? { \"Authorization\": \"Bearer \" + connection.accessToken } : {},\r\n                        success: function success(result) {\r\n                            var minData,\r\n                                delay = 0,\r\n                                data,\r\n                                shouldReconnect;\r\n\r\n                            connection.log(\"Long poll complete.\");\r\n\r\n                            // Reset our reconnect errors so if we transition into a reconnecting state again we trigger\r\n                            // reconnected quickly\r\n                            reconnectErrors = 0;\r\n\r\n                            try {\r\n                                // Remove any keep-alives from the beginning of the result\r\n                                minData = connection._parseResponse(result);\r\n                            } catch (error) {\r\n                                transportLogic.handleParseFailure(instance, result, error, tryFailConnect, instance.pollXhr);\r\n                                return;\r\n                            }\r\n\r\n                            // If there's currently a timeout to trigger reconnect, fire it now before processing messages\r\n                            if (privateData.reconnectTimeoutId !== null) {\r\n                                fireReconnected(instance);\r\n                            }\r\n\r\n                            if (minData) {\r\n                                data = transportLogic.maximizePersistentResponse(minData);\r\n                            }\r\n\r\n                            transportLogic.processMessages(instance, minData, _fireConnect);\r\n\r\n                            if (data && $.type(data.LongPollDelay) === \"number\") {\r\n                                delay = data.LongPollDelay;\r\n                            }\r\n\r\n                            if (isDisconnecting(instance) === true) {\r\n                                return;\r\n                            }\r\n\r\n                            shouldReconnect = data && data.ShouldReconnect;\r\n                            if (shouldReconnect) {\r\n                                // Transition into the reconnecting state\r\n                                // If this fails then that means that the user transitioned the connection into a invalid state in processMessages.\r\n                                if (!transportLogic.ensureReconnectingState(instance)) {\r\n                                    return;\r\n                                }\r\n                            }\r\n\r\n                            // We never want to pass a raiseReconnect flag after a successful poll.  This is handled via the error function\r\n                            if (delay > 0) {\r\n                                privateData.pollTimeoutId = window.setTimeout(function () {\r\n                                    poll(instance, shouldReconnect);\r\n                                }, delay);\r\n                            } else {\r\n                                poll(instance, shouldReconnect);\r\n                            }\r\n                        },\r\n\r\n                        error: function error(data, textStatus) {\r\n                            var error = signalR._.transportError(signalR.resources.longPollFailed, connection.transport, data, instance.pollXhr);\r\n\r\n                            // Stop trying to trigger reconnect, connection is in an error state\r\n                            // If we're not in the reconnect state this will noop\r\n                            window.clearTimeout(privateData.reconnectTimeoutId);\r\n                            privateData.reconnectTimeoutId = null;\r\n\r\n                            if (textStatus === \"abort\") {\r\n                                connection.log(\"Aborted xhr request.\");\r\n                                return;\r\n                            }\r\n\r\n                            if (!tryFailConnect(error)) {\r\n\r\n                                // Increment our reconnect errors, we assume all errors to be reconnect errors\r\n                                // In the case that it's our first error this will cause Reconnect to be fired\r\n                                // after 1 second due to reconnectErrors being = 1.\r\n                                reconnectErrors++;\r\n\r\n                                if (connection.state !== signalR.connectionState.reconnecting) {\r\n                                    connection.log(\"An error occurred using longPolling. Status = \" + textStatus + \".  Response = \" + data.responseText + \".\");\r\n                                    $(instance).triggerHandler(events.onError, [error]);\r\n                                }\r\n\r\n                                // We check the state here to verify that we're not in an invalid state prior to verifying Reconnect.\r\n                                // If we're not in connected or reconnecting then the next ensureReconnectingState check will fail and will return.\r\n                                // Therefore we don't want to change that failure code path.\r\n                                if ((connection.state === signalR.connectionState.connected || connection.state === signalR.connectionState.reconnecting) && !transportLogic.verifyLastActive(connection)) {\r\n                                    return;\r\n                                }\r\n\r\n                                // Transition into the reconnecting state\r\n                                // If this fails then that means that the user transitioned the connection into the disconnected or connecting state within the above error handler trigger.\r\n                                if (!transportLogic.ensureReconnectingState(instance)) {\r\n                                    return;\r\n                                }\r\n\r\n                                // Call poll with the raiseReconnect flag as true after the reconnect delay\r\n                                privateData.pollTimeoutId = window.setTimeout(function () {\r\n                                    poll(instance, true);\r\n                                }, that.reconnectDelay);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    // This will only ever pass after an error has occurred via the poll ajax procedure.\r\n                    if (reconnecting && raiseReconnect === true) {\r\n                        // We wait to reconnect depending on how many times we've failed to reconnect.\r\n                        // This is essentially a heuristic that will exponentially increase in wait time before\r\n                        // triggering reconnected.  This depends on the \"error\" handler of Poll to cancel this\r\n                        // timeout if it triggers before the Reconnected event fires.\r\n                        // The Math.min at the end is to ensure that the reconnect timeout does not overflow.\r\n                        privateData.reconnectTimeoutId = window.setTimeout(function () {\r\n                            fireReconnected(instance);\r\n                        }, Math.min(1000 * (Math.pow(2, reconnectErrors) - 1), maxFireReconnectedTimeout));\r\n                    }\r\n                })(connection);\r\n            }, 250); // Have to delay initial poll so Chrome doesn't show loader spinner in tab\r\n        },\r\n\r\n        lostConnection: function lostConnection(connection) {\r\n            if (connection.pollXhr) {\r\n                connection.pollXhr.abort(\"lostConnection\");\r\n            }\r\n        },\r\n\r\n        send: function send(connection, data) {\r\n            transportLogic.ajaxSend(connection, data);\r\n        },\r\n\r\n        stop: function stop(connection) {\r\n            /// <summary>Stops the long polling connection</summary>\r\n            /// <param name=\"connection\" type=\"signalR\">The SignalR connection to stop</param>\r\n\r\n            window.clearTimeout(connection._.pollTimeoutId);\r\n            window.clearTimeout(connection._.reconnectTimeoutId);\r\n\r\n            delete connection._.pollTimeoutId;\r\n            delete connection._.reconnectTimeoutId;\r\n\r\n            if (connection.pollXhr) {\r\n                connection.pollXhr.abort();\r\n                connection.pollXhr = null;\r\n                delete connection.pollXhr;\r\n            }\r\n        },\r\n\r\n        abort: function abort(connection, async) {\r\n            transportLogic.ajaxAbort(connection, async);\r\n        }\r\n    };\r\n})(jQueryShim, window);\r\n/* jquery.signalR.hubs.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.core.js\" />\r\n\r\n(function ($, window, undefined) {\r\n\r\n    var nextGuid = 0;\r\n    var eventNamespace = \".hubProxy\",\r\n        signalR = $.signalR;\r\n\r\n    function makeEventName(event) {\r\n        return event + eventNamespace;\r\n    }\r\n\r\n    // Equivalent to Array.prototype.map\r\n    function map(arr, fun, thisp) {\r\n        var i,\r\n            length = arr.length,\r\n            result = [];\r\n        for (i = 0; i < length; i += 1) {\r\n            if (arr.hasOwnProperty(i)) {\r\n                result[i] = fun.call(thisp, arr[i], i, arr);\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n\r\n    function getArgValue(a) {\r\n        return $.isFunction(a) ? null : $.type(a) === \"undefined\" ? null : a;\r\n    }\r\n\r\n    function hasMembers(obj) {\r\n        for (var key in obj) {\r\n            // If we have any properties in our callback map then we have callbacks and can exit the loop via return\r\n            if (obj.hasOwnProperty(key)) {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    function clearInvocationCallbacks(connection, error) {\r\n        /// <param name=\"connection\" type=\"hubConnection\" />\r\n        var callbacks = connection._.invocationCallbacks,\r\n            callback;\r\n\r\n        if (hasMembers(callbacks)) {\r\n            connection.log(\"Clearing hub invocation callbacks with error: \" + error + \".\");\r\n        }\r\n\r\n        // Reset the callback cache now as we have a local var referencing it\r\n        connection._.invocationCallbackId = 0;\r\n        delete connection._.invocationCallbacks;\r\n        connection._.invocationCallbacks = {};\r\n\r\n        // Loop over the callbacks and invoke them.\r\n        // We do this using a local var reference and *after* we've cleared the cache\r\n        // so that if a fail callback itself tries to invoke another method we don't\r\n        // end up with its callback in the list we're looping over.\r\n        for (var callbackId in callbacks) {\r\n            callback = callbacks[callbackId];\r\n            callback.method.call(callback.scope, { E: error });\r\n        }\r\n    }\r\n\r\n    function isCallbackFromGeneratedHubProxy(callback) {\r\n        // https://github.com/SignalR/SignalR/issues/4310\r\n        // The stringified callback from the old generated hub proxy is 137 characters in Edge, Firefox and Chrome.\r\n        // We slice to avoid wasting too many cycles searching through the text of a long large function.\r\n        return $.isFunction(callback) && callback.toString().slice(0, 256).indexOf(\"// Call the client hub method\") >= 0;\r\n    }\r\n\r\n    // hubProxy\r\n    function hubProxy(hubConnection, hubName) {\r\n        /// <summary>\r\n        ///     Creates a new proxy object for the given hub connection that can be used to invoke\r\n        ///     methods on server hubs and handle client method invocation requests from the server.\r\n        /// </summary>\r\n        return new hubProxy.fn.init(hubConnection, hubName);\r\n    }\r\n\r\n    hubProxy.fn = hubProxy.prototype = {\r\n        init: function init(connection, hubName) {\r\n            this.state = {};\r\n            this.connection = connection;\r\n            this.hubName = hubName;\r\n            this._ = {\r\n                callbackMap: {}\r\n            };\r\n        },\r\n\r\n        constructor: hubProxy,\r\n\r\n        hasSubscriptions: function hasSubscriptions() {\r\n            return hasMembers(this._.callbackMap);\r\n        },\r\n\r\n        on: function on(eventName, callback, callbackIdentity) {\r\n            /// <summary>Wires up a callback to be invoked when a invocation request is received from the server hub.</summary>\r\n            /// <param name=\"eventName\" type=\"String\">The name of the hub event to register the callback for.</param>\r\n            /// <param name=\"callback\" type=\"Function\">The callback to be invoked.</param>\r\n            /// <param name=\"callbackIdentity\" type=\"Object\">An optional object to use as the \"identity\" for the callback when checking if the handler has already been registered. Defaults to the value of 'callback' if not provided.</param>\r\n            var that = this,\r\n                callbackMap = that._.callbackMap,\r\n                isFromOldGeneratedHubProxy = !callbackIdentity && isCallbackFromGeneratedHubProxy(callback);\r\n\r\n            // We need the third \"identity\" argument because the registerHubProxies call made by signalr/js wraps the user-provided callback in a custom wrapper which breaks the identity comparison.\r\n            // callbackIdentity allows the caller of `on` to provide a separate object to use as the \"identity\". `registerHubProxies` uses the original user callback as this identity object.\r\n            callbackIdentity = callbackIdentity || callback;\r\n\r\n            // Assign a global ID to the identity object. This tags the object so we can detect the same object when it comes back.\r\n            if (!callbackIdentity._signalRGuid) {\r\n                callbackIdentity._signalRGuid = nextGuid++;\r\n            }\r\n\r\n            // Normalize the event name to lowercase\r\n            eventName = eventName.toLowerCase();\r\n\r\n            // If there is not an event registered for this callback yet we want to create its event space in the callback map.\r\n            var callbackSpace = callbackMap[eventName];\r\n            if (!callbackSpace) {\r\n                callbackSpace = [];\r\n                callbackMap[eventName] = callbackSpace;\r\n            }\r\n\r\n            // Check if there's already a registration\r\n            var registration;\r\n            for (var i = 0; i < callbackSpace.length; i++) {\r\n                if (callbackSpace[i].guid === callbackIdentity._signalRGuid || isFromOldGeneratedHubProxy && callbackSpace[i].isFromOldGeneratedHubProxy) {\r\n                    registration = callbackSpace[i];\r\n                }\r\n            }\r\n\r\n            // Create a registration if there isn't one already\r\n            if (!registration) {\r\n                registration = {\r\n                    guid: callbackIdentity._signalRGuid,\r\n                    eventHandlers: [],\r\n                    isFromOldGeneratedHubProxy: isFromOldGeneratedHubProxy\r\n                };\r\n                callbackMap[eventName].push(registration);\r\n            }\r\n\r\n            var handler = function handler(e, data) {\r\n                callback.apply(that, data);\r\n            };\r\n            registration.eventHandlers.push(handler);\r\n\r\n            $(that).bind(makeEventName(eventName), handler);\r\n\r\n            return that;\r\n        },\r\n\r\n        off: function off(eventName, callback, callbackIdentity) {\r\n            /// <summary>Removes the callback invocation request from the server hub for the given event name.</summary>\r\n            /// <param name=\"eventName\" type=\"String\">The name of the hub event to unregister the callback for.</param>\r\n            /// <param name=\"callback\" type=\"Function\">The callback to be removed.</param>\r\n            /// <param name=\"callbackIdentity\" type=\"Object\">An optional object to use as the \"identity\" when looking up the callback. Corresponds to the same parameter provided to 'on'. Defaults to the value of 'callback' if not provided.</param>\r\n            var that = this,\r\n                callbackMap = that._.callbackMap,\r\n                callbackSpace,\r\n                isFromOldGeneratedHubProxy = !callbackIdentity && isCallbackFromGeneratedHubProxy(callback);\r\n\r\n            callbackIdentity = callbackIdentity || callback;\r\n\r\n            // Normalize the event name to lowercase\r\n            eventName = eventName.toLowerCase();\r\n\r\n            callbackSpace = callbackMap[eventName];\r\n\r\n            // Verify that there is an event space to unbind\r\n            if (callbackSpace) {\r\n\r\n                if (callback) {\r\n                    // Find the callback registration\r\n                    var callbackRegistration;\r\n                    var callbackIndex;\r\n                    for (var i = 0; i < callbackSpace.length; i++) {\r\n                        if (callbackSpace[i].guid === callbackIdentity._signalRGuid || isFromOldGeneratedHubProxy && callbackSpace[i].isFromOldGeneratedHubProxy) {\r\n                            callbackIndex = i;\r\n                            callbackRegistration = callbackSpace[i];\r\n                        }\r\n                    }\r\n\r\n                    // Only unbind if there's an event bound with eventName and a callback with the specified callback\r\n                    if (callbackRegistration) {\r\n                        // Unbind all event handlers associated with the registration.\r\n                        for (var j = 0; j < callbackRegistration.eventHandlers.length; j++) {\r\n                            $(that).unbind(makeEventName(eventName), callbackRegistration.eventHandlers[j]);\r\n                        }\r\n\r\n                        // Remove the registration from the list\r\n                        callbackSpace.splice(i, 1);\r\n\r\n                        // Check if there are any registrations left, if not we need to destroy it.\r\n                        if (callbackSpace.length === 0) {\r\n                            delete callbackMap[eventName];\r\n                        }\r\n                    }\r\n                } else if (!callback) {\r\n                    // Check if we're removing the whole event and we didn't error because of an invalid callback\r\n                    $(that).unbind(makeEventName(eventName));\r\n\r\n                    delete callbackMap[eventName];\r\n                }\r\n            }\r\n\r\n            return that;\r\n        },\r\n\r\n        invoke: function invoke(methodName) {\r\n            /// <summary>Invokes a server hub method with the given arguments.</summary>\r\n            /// <param name=\"methodName\" type=\"String\">The name of the server hub method.</param>\r\n\r\n            var that = this,\r\n                connection = that.connection,\r\n                args = $.makeArray(arguments).slice(1),\r\n                argValues = map(args, getArgValue),\r\n                data = { H: that.hubName, M: methodName, A: argValues, I: connection._.invocationCallbackId },\r\n                d = $.Deferred(),\r\n                callback = function callback(minResult) {\r\n                var result = that._maximizeHubResponse(minResult),\r\n                    source,\r\n                    error;\r\n\r\n                // Update the hub state\r\n                $.extend(that.state, result.State);\r\n\r\n                if (result.Progress) {\r\n                    if (d.notifyWith) {\r\n                        // Progress is only supported in jQuery 1.7+\r\n                        d.notifyWith(that, [result.Progress.Data]);\r\n                    } else if (!connection._.progressjQueryVersionLogged) {\r\n                        connection.log(\"A hub method invocation progress update was received but the version of jQuery in use (\" + $.prototype.jquery + \") does not support progress updates. Upgrade to jQuery 1.7+ to receive progress notifications.\");\r\n                        connection._.progressjQueryVersionLogged = true;\r\n                    }\r\n                } else if (result.Error) {\r\n                    // Server hub method threw an exception, log it & reject the deferred\r\n                    if (result.StackTrace) {\r\n                        connection.log(result.Error + \"\\n\" + result.StackTrace + \".\");\r\n                    }\r\n\r\n                    // result.ErrorData is only set if a HubException was thrown\r\n                    source = result.IsHubException ? \"HubException\" : \"Exception\";\r\n                    error = signalR._.error(result.Error, source);\r\n                    error.data = result.ErrorData;\r\n\r\n                    connection.log(that.hubName + \".\" + methodName + \" failed to execute. Error: \" + error.message);\r\n                    d.rejectWith(that, [error]);\r\n                } else {\r\n                    // Server invocation succeeded, resolve the deferred\r\n                    connection.log(\"Invoked \" + that.hubName + \".\" + methodName);\r\n                    d.resolveWith(that, [result.Result]);\r\n                }\r\n            };\r\n\r\n            connection._.invocationCallbacks[connection._.invocationCallbackId.toString()] = { scope: that, method: callback };\r\n            connection._.invocationCallbackId += 1;\r\n\r\n            if (!$.isEmptyObject(that.state)) {\r\n                data.S = that.state;\r\n            }\r\n\r\n            connection.log(\"Invoking \" + that.hubName + \".\" + methodName);\r\n            connection.send(data);\r\n\r\n            return d.promise();\r\n        },\r\n\r\n        _maximizeHubResponse: function _maximizeHubResponse(minHubResponse) {\r\n            return {\r\n                State: minHubResponse.S,\r\n                Result: minHubResponse.R,\r\n                Progress: minHubResponse.P ? {\r\n                    Id: minHubResponse.P.I,\r\n                    Data: minHubResponse.P.D\r\n                } : null,\r\n                Id: minHubResponse.I,\r\n                IsHubException: minHubResponse.H,\r\n                Error: minHubResponse.E,\r\n                StackTrace: minHubResponse.T,\r\n                ErrorData: minHubResponse.D\r\n            };\r\n        }\r\n    };\r\n\r\n    hubProxy.fn.init.prototype = hubProxy.fn;\r\n\r\n    // hubConnection\r\n    function hubConnection(url, options) {\r\n        /// <summary>Creates a new hub connection.</summary>\r\n        /// <param name=\"url\" type=\"String\">[Optional] The hub route url, defaults to \"/signalr\".</param>\r\n        /// <param name=\"options\" type=\"Object\">[Optional] Settings to use when creating the hubConnection.</param>\r\n        var settings = {\r\n            qs: null,\r\n            logging: false,\r\n            useDefaultPath: true\r\n        };\r\n\r\n        $.extend(settings, options);\r\n\r\n        if (!url || settings.useDefaultPath) {\r\n            url = (url || \"\") + \"/signalr\";\r\n        }\r\n        return new hubConnection.fn.init(url, settings);\r\n    }\r\n\r\n    hubConnection.fn = hubConnection.prototype = $.connection();\r\n\r\n    hubConnection.fn.init = function (url, options) {\r\n        var settings = {\r\n            qs: null,\r\n            logging: false,\r\n            useDefaultPath: true\r\n        },\r\n            connection = this;\r\n\r\n        $.extend(settings, options);\r\n\r\n        // Call the base constructor\r\n        $.signalR.fn.init.call(connection, url, settings.qs, settings.logging);\r\n\r\n        // Object to store hub proxies for this connection\r\n        connection.proxies = {};\r\n\r\n        connection._.invocationCallbackId = 0;\r\n        connection._.invocationCallbacks = {};\r\n\r\n        // Wire up the received handler\r\n        connection.received(function (minData) {\r\n            var data, proxy, dataCallbackId, callback, hubName, eventName;\r\n            if (!minData) {\r\n                return;\r\n            }\r\n\r\n            // We have to handle progress updates first in order to ensure old clients that receive\r\n            // progress updates enter the return value branch and then no-op when they can't find\r\n            // the callback in the map (because the minData.I value will not be a valid callback ID)\r\n            // Process progress notification\r\n            if (typeof minData.P !== \"undefined\") {\r\n                dataCallbackId = minData.P.I.toString();\r\n                callback = connection._.invocationCallbacks[dataCallbackId];\r\n                if (callback) {\r\n                    callback.method.call(callback.scope, minData);\r\n                }\r\n            } else if (typeof minData.I !== \"undefined\") {\r\n                // We received the return value from a server method invocation, look up callback by id and call it\r\n                dataCallbackId = minData.I.toString();\r\n                callback = connection._.invocationCallbacks[dataCallbackId];\r\n                if (callback) {\r\n                    // Delete the callback from the proxy\r\n                    connection._.invocationCallbacks[dataCallbackId] = null;\r\n                    delete connection._.invocationCallbacks[dataCallbackId];\r\n\r\n                    // Invoke the callback\r\n                    callback.method.call(callback.scope, minData);\r\n                }\r\n            } else {\r\n                data = this._maximizeClientHubInvocation(minData);\r\n\r\n                // We received a client invocation request, i.e. broadcast from server hub\r\n                connection.log(\"Triggering client hub event '\" + data.Method + \"' on hub '\" + data.Hub + \"'.\");\r\n\r\n                // Normalize the names to lowercase\r\n                hubName = data.Hub.toLowerCase();\r\n                eventName = data.Method.toLowerCase();\r\n\r\n                // Trigger the local invocation event\r\n                proxy = this.proxies[hubName];\r\n\r\n                // Update the hub state\r\n                $.extend(proxy.state, data.State);\r\n                $(proxy).triggerHandler(makeEventName(eventName), [data.Args]);\r\n            }\r\n        });\r\n\r\n        connection.error(function (errData, origData) {\r\n            var callbackId, callback;\r\n\r\n            if (!origData) {\r\n                // No original data passed so this is not a send error\r\n                return;\r\n            }\r\n\r\n            callbackId = origData.I;\r\n            callback = connection._.invocationCallbacks[callbackId];\r\n\r\n            // Verify that there is a callback bound (could have been cleared)\r\n            if (callback) {\r\n                // Delete the callback\r\n                connection._.invocationCallbacks[callbackId] = null;\r\n                delete connection._.invocationCallbacks[callbackId];\r\n\r\n                // Invoke the callback with an error to reject the promise\r\n                callback.method.call(callback.scope, { E: errData });\r\n            }\r\n        });\r\n\r\n        connection.reconnecting(function () {\r\n            if (connection.transport && connection.transport.name === \"webSockets\") {\r\n                clearInvocationCallbacks(connection, \"Connection started reconnecting before invocation result was received.\");\r\n            }\r\n        });\r\n\r\n        connection.disconnected(function () {\r\n            clearInvocationCallbacks(connection, \"Connection was disconnected before invocation result was received.\");\r\n        });\r\n    };\r\n\r\n    hubConnection.fn._maximizeClientHubInvocation = function (minClientHubInvocation) {\r\n        return {\r\n            Hub: minClientHubInvocation.H,\r\n            Method: minClientHubInvocation.M,\r\n            Args: minClientHubInvocation.A,\r\n            State: minClientHubInvocation.S\r\n        };\r\n    };\r\n\r\n    hubConnection.fn._registerSubscribedHubs = function () {\r\n        /// <summary>\r\n        ///     Sets the starting event to loop through the known hubs and register any new hubs\r\n        ///     that have been added to the proxy.\r\n        /// </summary>\r\n        var connection = this;\r\n\r\n        if (!connection._subscribedToHubs) {\r\n            connection._subscribedToHubs = true;\r\n            connection.starting(function () {\r\n                // Set the connection's data object with all the hub proxies with active subscriptions.\r\n                // These proxies will receive notifications from the server.\r\n                var subscribedHubs = [];\r\n\r\n                $.each(connection.proxies, function (key) {\r\n                    if (this.hasSubscriptions()) {\r\n                        subscribedHubs.push({ name: key });\r\n                        connection.log(\"Client subscribed to hub '\" + key + \"'.\");\r\n                    }\r\n                });\r\n\r\n                if (subscribedHubs.length === 0) {\r\n                    connection.log(\"No hubs have been subscribed to.  The client will not receive data from hubs.  To fix, declare at least one client side function prior to connection start for each hub you wish to subscribe to.\");\r\n                }\r\n\r\n                connection.data = connection.json.stringify(subscribedHubs);\r\n            });\r\n        }\r\n    };\r\n\r\n    hubConnection.fn.createHubProxy = function (hubName) {\r\n        /// <summary>\r\n        ///     Creates a new proxy object for the given hub connection that can be used to invoke\r\n        ///     methods on server hubs and handle client method invocation requests from the server.\r\n        /// </summary>\r\n        /// <param name=\"hubName\" type=\"String\">\r\n        ///     The name of the hub on the server to create the proxy for.\r\n        /// </param>\r\n\r\n        // Normalize the name to lowercase\r\n        hubName = hubName.toLowerCase();\r\n\r\n        var proxy = this.proxies[hubName];\r\n        if (!proxy) {\r\n            proxy = hubProxy(this, hubName);\r\n            this.proxies[hubName] = proxy;\r\n        }\r\n\r\n        this._registerSubscribedHubs();\r\n\r\n        return proxy;\r\n    };\r\n\r\n    hubConnection.fn.init.prototype = hubConnection.fn;\r\n\r\n    $.hubConnection = hubConnection;\r\n})(jQueryShim, window);\r\n/* jquery.signalR.version.js */\r\n// Copyright (c) .NET Foundation. All rights reserved.\r\n// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.\r\n\r\n\r\n/*global window:false */\r\n/// <reference path=\"jquery.signalR.core.js\" />\r\n(function ($, undefined) {\r\n    // This will be modified by the build script\r\n    $.signalR.version = \"2.4.1\";\r\n})(jQueryShim);\r\n\r\nvar hubConnection = exports.hubConnection = jQueryShim.hubConnection;\r\nvar signalR = exports.signalR = jQueryShim.signalR;","import { hubConnection, Proxy, Connection } from \"signalr-no-jquery\";\r\nimport { Engine } from \"./engine\";\r\n\r\ninterface IExtendedConnection extends Connection {\r\n    reconnected(callback: () => void): void;\r\n}\r\n\r\n/**\r\n * The engine that can connect to an ASP.Net WebForms server.\r\n */\r\nexport class AspNetEngine extends Engine {\r\n    private hub: Proxy | null = null;\r\n\r\n    /**\r\n     * Creates a new engine that can connect to an ASP.Net WebForms server.\r\n     */\r\n    public constructor() {\r\n        super();\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    public override get connectionId(): string | null {\r\n        return this.hub?.connection.id || null;\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    protected startConnection(): Promise<void> {\r\n        return new Promise<void>((resolve, reject) => {\r\n            const connection = hubConnection(\"/rock-rt\", { useDefaultPath: false }) as IExtendedConnection;\r\n            const hub = connection.createHubProxy(\"realTime\");\r\n\r\n            hub.on(\"message\", this.onMessage.bind(this));\r\n            connection.reconnecting(() => this.onTransportReconnecting());\r\n            connection.reconnected(() => this.onTransportReconnect());\r\n            connection.disconnected(() => {\r\n                this.hub = null;\r\n                this.onTransportDisconnect();\r\n            });\r\n\r\n            connection.start()\r\n                .done(() => {\r\n                    this.hub = hub;\r\n                    resolve();\r\n                })\r\n                .fail(() => {\r\n                    reject(new Error(\"Failed to connect to RealTime hub.\"));\r\n                });\r\n        });\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    protected closeConnection(): Promise<void> {\r\n        return new Promise((resolve) => {\r\n\r\n            if (this.hub) {\r\n                this.hub.connection.stop();\r\n                this.hub = null;\r\n            }\r\n\r\n            resolve();\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Called when a message is received from the hub.\r\n     *\r\n     * @param topicIdentifier The identifier of the topic that the message is intended for.\r\n     * @param messageName The name of the message that was received.\r\n     * @param messageParams The parameters to the message.\r\n     */\r\n    private onMessage(topicIdentifier: string, messageName: string, messageParams: unknown[]): void {\r\n        this.emit(topicIdentifier, messageName, messageParams);\r\n    }\r\n\r\n    /** @inheritdoc */\r\n    public override async invokeCore(messageName: string, ...args: unknown[]): Promise<unknown> {\r\n        if (!this.hub) {\r\n            throw new Error(\"Connection to the RealTime system was lost.\");\r\n        }\r\n\r\n        return await this.hub.invoke(messageName, ...args);\r\n    }\r\n}\r\n","import mitt, { Emitter, EventType } from \"mitt\";\r\n\r\n/**\r\n * Simple deferred promise that can be completed at a later time.\r\n */\r\nclass PromiseCompletionSource<T = void> {\r\n    private resolvePromise!: ((value: T) => void);\r\n    private rejectPromise!: ((reason?: unknown) => void);\r\n    private internalPromise: Promise<T>;\r\n\r\n    constructor() {\r\n        this.internalPromise = new Promise<T>((resolve, reject) => {\r\n            this.resolvePromise = resolve;\r\n            this.rejectPromise = reject;\r\n        });\r\n    }\r\n\r\n    public resolve(value: T): void {\r\n        this.resolvePromise(value);\r\n    }\r\n\r\n    public reject(reason?: unknown): void {\r\n        this.rejectPromise(reason);\r\n    }\r\n\r\n    public get promise(): Promise<T> {\r\n        return this.internalPromise;\r\n    }\r\n}\r\n\r\nfunction isPromise<T>(obj: PromiseLike<T> | T): obj is PromiseLike<T> {\r\n    return !!obj && (typeof obj === \"object\" || typeof obj === \"function\") && typeof (obj as Record<string, unknown>).then === \"function\";\r\n}\r\n\r\nconst maxReconnectAttempts = 10;\r\nconst reconnectDelay: number[] = [500, 2_500, 5_000, 10_000, 30_000];\r\n\r\n/**\r\n * General functionality for any RealTime engine.\r\n */\r\nexport abstract class Engine {\r\n    private readonly emitter: Emitter<Record<EventType, unknown[]>>;\r\n    private startPromise: PromiseCompletionSource | null = null;\r\n    private reconnectPromise: PromiseCompletionSource | null = null;\r\n    private reconnectAttemptCount: number = 0;\r\n    private reconnectTimer: NodeJS.Timeout | null = null;\r\n    private reconnectCallbacks: ((() => void) | (() => PromiseLike<void>))[] = [];\r\n    private disconnectCallbacks: (() => void)[] = [];\r\n    private isDisconnectedInternal: boolean = false;\r\n\r\n    protected constructor() {\r\n        this.emitter = mitt();\r\n    }\r\n\r\n    /**\r\n     * Get the identifier that uniquely identifiers our connection to the server.\r\n     * Returns null is not yet connected.\r\n     */\r\n    public abstract get connectionId(): string | null;\r\n\r\n    /**\r\n     * Start the connection to the RealTime backend. This may be called more\r\n     * than once to perform a reconnect, but closeConnection should always\r\n     * be called before this is.\r\n     */\r\n    protected abstract startConnection(): Promise<void>;\r\n\r\n    /**\r\n     * Close the transport connection to the RealTime backend.\r\n     */\r\n    protected abstract closeConnection(): Promise<void>;\r\n\r\n    /**\r\n     * Invokes the message and sends it up to the Rock server.\r\n     *\r\n     * @param topicIdentifier The identifier of the topic to send the message to.\r\n     * @param messageName The name of the message to be sent.\r\n     * @param messageParams The parameters to pass to the message.\r\n     *\r\n     * @returns The value returned by the message call.\r\n     */\r\n    public async invoke(topicIdentifier: string, messageName: string, messageParams: unknown[]): Promise<unknown> {\r\n        return await this.invokeCore(\"postMessage\", topicIdentifier, messageName, messageParams);\r\n    }\r\n\r\n    /**\r\n     * Invokes the core engine message and sends it up to the Rock server.\r\n     *\r\n     * @param messageName The name of the message to be sent.\r\n     * @param messageParams The parameters to pass to the message.\r\n     *\r\n     * @returns The value returned by the message call.\r\n     */\r\n    public abstract invokeCore(messageName: string, ...args: unknown[]): Promise<unknown>;\r\n\r\n    /**\r\n     * Makes sure the engine is connected to the RealTime system and waits\r\n     * until it is connected. Throws an exception if could not be connected.\r\n     */\r\n    public async ensureConnected(): Promise<void> {\r\n        if (this.isDisconnected) {\r\n            throw new Error(\"RealTime engine is disconnected.\");\r\n        }\r\n\r\n        if (this.startPromise) {\r\n            await this.startPromise.promise;\r\n\r\n            if (this.reconnectPromise) {\r\n                await this.reconnectPromise.promise;\r\n            }\r\n\r\n            return;\r\n        }\r\n\r\n        this.startPromise = new PromiseCompletionSource();\r\n        try {\r\n            await this.startConnection();\r\n            this.startPromise.resolve();\r\n        }\r\n        catch (error: unknown) {\r\n            this.disconnected();\r\n            this.startPromise.reject(error);\r\n\r\n            throw error;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets a value that indicates if the engine is currently reconnecting.\r\n     */\r\n    public get isReconnecting(): boolean {\r\n        return this.reconnectPromise !== null;\r\n    }\r\n\r\n    /**\r\n     * Gets a value that indicates if the engine is disconnected. This will\r\n     * return true if no more attempts to connect will be made.\r\n     */\r\n    public get isDisconnected(): boolean {\r\n        return this.isDisconnectedInternal;\r\n    }\r\n\r\n    /**\r\n     * Notification that the engine is attempting to perform transport level\r\n     * reconnection.\r\n     */\r\n    protected onTransportReconnecting(): void {\r\n        if (!this.reconnectPromise) {\r\n            this.reconnectPromise = new PromiseCompletionSource();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Notification that the engine has completed a transport level reconnection.\r\n     * A reconnect can be successful even if the transport has connected to an\r\n     * entirely different server - which is an invalid state for us.\r\n     */\r\n    protected async onTransportReconnect(): Promise<void> {\r\n        if (!this.reconnectPromise) {\r\n            return;\r\n        }\r\n\r\n        // Check if the server still knows about our connection.\r\n        if (await this.invokeCore(\"isConnectionValid\") === true) {\r\n            this.reconnectPromise.resolve();\r\n            this.reconnectPromise = null;\r\n            return;\r\n        }\r\n\r\n        this.scheduleReconnectAttempt();\r\n    }\r\n\r\n    /**\r\n     * Notification that the engine has had a transport level disconnection.\r\n     * No automatic reconnect attempts are being performed by the transport.\r\n     */\r\n    protected onTransportDisconnect(): void {\r\n        this.scheduleReconnectAttempt();\r\n    }\r\n\r\n    /**\r\n     * Schedule a reconnect attempt. This is not a transport level reconnect\r\n     * so all connection state has been lost.\r\n     */\r\n    private scheduleReconnectAttempt(): void {\r\n        if (this.isDisconnected || this.reconnectTimer) {\r\n            return;\r\n        }\r\n\r\n        if (!this.reconnectPromise) {\r\n            this.reconnectPromise = new PromiseCompletionSource();\r\n        }\r\n\r\n        this.reconnectAttemptCount += 1;\r\n        this.reconnectTimer = setTimeout(() => this.attemptReconnect(), this.getReconnectDelay());\r\n    }\r\n\r\n    /**\r\n     * Attempt a full reconnect. First we ensure we are fully disconnected at\r\n     * the transport level and then start a new connection.\r\n     */\r\n    private async attemptReconnect(): Promise<void> {\r\n        try {\r\n            // Close the connection and then start it again. After we have\r\n            // connected call our reconnected function to emit callbacks.\r\n            await this.closeConnection();\r\n            await this.startConnection();\r\n            await this.reconnected();\r\n        }\r\n        catch (error) {\r\n            this.reconnectAttemptCount += 1;\r\n\r\n            if (this.reconnectAttemptCount <= maxReconnectAttempts) {\r\n                this.reconnectTimer = setTimeout(() => this.attemptReconnect(), this.getReconnectDelay());\r\n            }\r\n            else {\r\n                this.disconnected();\r\n\r\n                throw error;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the time to wait before attempting to reconnect.\r\n     *\r\n     * @returns The number of milliseconds to wait.\r\n     */\r\n    private getReconnectDelay(): number {\r\n        return this.reconnectAttemptCount < reconnectDelay.length\r\n            ? reconnectDelay[this.reconnectAttemptCount]\r\n            : reconnectDelay[reconnectDelay.length - 1];\r\n    }\r\n\r\n    /**\r\n     * Called once we have performed a full reconnection and need to fire all\r\n     * reconnect callbacks.\r\n     */\r\n    private async reconnected(): Promise<void> {\r\n        for (const callback of this.reconnectCallbacks) {\r\n            try {\r\n                const result = callback();\r\n\r\n                if (isPromise(result)) {\r\n                    await result;\r\n                }\r\n            }\r\n            catch (error) {\r\n                console.error(error);\r\n            }\r\n        }\r\n\r\n        // Clean up the existing reconnection attempt data.\r\n        this.reconnectAttemptCount = 0;\r\n        this.reconnectPromise?.resolve();\r\n        this.reconnectPromise = null;\r\n        this.reconnectTimer = null;\r\n    }\r\n\r\n    /**\r\n     * Called once we have hit a full disconnect situation where we will\r\n     * no longer try to connect or reconnect.\r\n     */\r\n    private disconnected(): void {\r\n        this.isDisconnectedInternal = true;\r\n        this.reconnectPromise?.reject(\"RealTime engine is disconnected.\");\r\n        this.reconnectPromise = null;\r\n        this.reconnectTimer = null;\r\n\r\n        for (const callback of this.disconnectCallbacks) {\r\n            try {\r\n                callback();\r\n            }\r\n            catch (error) {\r\n                console.error(error);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Registers a callback to be called when the connection has been lost\r\n     * and then reconnected. This means a new connection identifier is now\r\n     * in use and any state information has been lost.\r\n     * \r\n     * @param callback The callback to be called.\r\n     */\r\n    public onReconnect(callback: (() => void) | (() => PromiseLike<void>)): void {\r\n        this.reconnectCallbacks.push(callback);\r\n    }\r\n\r\n    /**\r\n     * Registers a callback to be called when the connection has been lost\r\n     * and will no longer try to reconnect.\r\n     * \r\n     * @param callback The callback to be called.\r\n     */\r\n    public onDisconnect(callback: () => void): void {\r\n        this.disconnectCallbacks.push(callback);\r\n    }\r\n\r\n    /**\r\n     * Adds a listener for an incoming message to the specified topic.\r\n     *\r\n     * @param topicIdentifier The identifier of the topic that will receive the message.\r\n     * @param messageName The name of the message to be received.\r\n     * @param handler The function to call when a message is received.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any -- It's going to be up to caller to ensure they use the right handler arguments.\r\n    public on(topicIdentifier: string, messageName: string, handler: (...args: any[]) => void): void {\r\n        this.emitter.on(`${topicIdentifier}-${messageName}`, (eventArgs: unknown[]) => handler(...eventArgs));\r\n    }\r\n\r\n    /**\r\n     * Emits the event for the topic and message name.\r\n     * \r\n     * @param topicIdentifier The identifier of the topic that the message was received from.\r\n     * @param messageName The name of the message that was received.\r\n     * @param eventArgs The arguments that were sent with the message.\r\n     */\r\n    protected emit(topicIdentifier: string, messageName: string, eventArgs: unknown[]): void {\r\n        this.emitter.emit(`${topicIdentifier}-${messageName}`, eventArgs);\r\n    }\r\n}\r\n","import { AspNetEngine } from \"./aspNetEngine\";\r\nimport { Topic } from \"./topic\";\r\nimport { GenericServerFunctions, ServerFunctions } from \"./types\";\r\n\r\nconst engine = new AspNetEngine();\r\n\r\nasync function getTopic<TServer extends ServerFunctions<TServer> = GenericServerFunctions>(identifier: string): Promise<Topic<TServer>> {\r\n    await engine.ensureConnected();\r\n\r\n    const topic = new Topic<TServer>(identifier, engine);\r\n\r\n    await topic.connect();\r\n\r\n    return topic;\r\n}\r\n\r\nexport { getTopic };\r\n","import { GenericServerFunctions, ServerFunctions } from \"./types\";\r\nimport { Engine } from \"./engine\";\r\n\r\nfunction isPromise<T>(obj: PromiseLike<T> | T): obj is PromiseLike<T> {\r\n    return !!obj && (typeof obj === \"object\" || typeof obj === \"function\") && typeof (obj as Record<string, unknown>).then === \"function\";\r\n}\r\n\r\nfunction createServerProxy<TServer extends ServerFunctions<TServer> = GenericServerFunctions>(engine: Engine, identifier: string, skipReconnectingCheck: boolean): TServer {\r\n    return new Proxy<TServer>({} as TServer, {\r\n        get(_, propertyName) {\r\n            return async (...args: unknown[]): Promise<unknown> => {\r\n                if (typeof propertyName !== \"string\") {\r\n                    return;\r\n                }\r\n\r\n                if (!skipReconnectingCheck) {\r\n                    await engine.ensureConnected();\r\n                }\r\n\r\n                try {\r\n                    return await engine.invoke(identifier, propertyName, args);\r\n                }\r\n                catch (error) {\r\n                    if (engine.isDisconnected || skipReconnectingCheck || !engine.isReconnecting) {\r\n                        throw error;\r\n                    }\r\n\r\n                    await engine.ensureConnected();\r\n                    return await engine.invoke(identifier, propertyName, args);\r\n                }\r\n            };\r\n        }\r\n    });\r\n}\r\n\r\nexport class Topic<TServer extends ServerFunctions<TServer> = GenericServerFunctions> {\r\n    private engine: Engine;\r\n    private identifier: string;\r\n    private reconnectCallbacks: (((server: TServer) => void) | ((server: TServer) => PromiseLike<void>))[] = [];\r\n\r\n    /**\r\n     * Allows messages to be sent to the server. Any property access is treated\r\n     * like a message function whose property name is the message name.\r\n     */\r\n    public server: TServer;\r\n\r\n    /**\r\n     * Creates a new topic proxy that will facilitate communication with the\r\n     * Rock RealTime backend.\r\n     *\r\n     * @param identifier The unique identifier of the topic to connect to.\r\n     * @param engine The engine that will handle communication to the backend.\r\n     */\r\n    public constructor(identifier: string, engine: Engine) {\r\n        this.identifier = identifier;\r\n        this.engine = engine;\r\n\r\n        engine.onReconnect(async () => this.reconnected());\r\n\r\n        this.server = createServerProxy<TServer>(engine, identifier, false);\r\n    }\r\n\r\n    /**\r\n     * Gets the connection identifier for this topic. This will be the same for\r\n     * all topics, but that should not be relied on staying that way in the future.\r\n     */\r\n    public get connectionId(): string | null {\r\n        return this.engine.connectionId;\r\n    }\r\n\r\n    /**\r\n     * Gets a value that indicates if the topic is currently reconnecting.\r\n     */\r\n    public get isReconnecting(): boolean {\r\n        return this.engine.isReconnecting;\r\n    }\r\n\r\n    /**\r\n     * Gets a value that indicates if the topic is disconnected and will no\r\n     * longer try to connect to the server.\r\n     */\r\n    public get isDisconnected(): boolean {\r\n        return this.engine.isDisconnected;\r\n    }\r\n\r\n    /**\r\n     * Connects to the topic so that the backend knows of our presense.\r\n     */\r\n    public async connect(): Promise<void> {\r\n        await this.engine.invokeCore(\"connectToTopic\", this.identifier);\r\n    }\r\n\r\n    /**\r\n     * Registers a handler to be called when a message with the given name\r\n     * is received.\r\n     *\r\n     * @param messageName The message name that will trigger the handler.\r\n     * @param handler The handler to be called when a message is received.\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\r\n    public on(messageName: string, handler: ((...args: any[]) => void)): void {\r\n        this.engine.on(this.identifier, messageName, handler);\r\n    }\r\n\r\n    /**\r\n     * Registers a callback to be called when the connection has been lost\r\n     * and then reconnected. This means a new connection identifier is now\r\n     * in use and any state information has been lost.The callback will be\r\n     * called with a special server proxy that can be used while in a\r\n     * reconnecting state. The normal server proxy will pause messages until\r\n     * the reconnect is completed and all callbacks have finished.\r\n     * \r\n     * @param callback The callback to be called.\r\n     */\r\n    public onReconnect(callback: ((server: TServer) => void) | ((server: TServer) => PromiseLike<void>)): void {\r\n        this.reconnectCallbacks.push(callback);\r\n    }\r\n\r\n    /**\r\n     * Registers a callback to be called when the connection has been lost\r\n     * and will no longer try to reconnect.\r\n     * \r\n     * @param callback The callback to be called.\r\n     */\r\n    public onDisconnect(callback: (() => void) | (() => PromiseLike<void>)): void {\r\n        this.engine.onDisconnect(callback);\r\n    }\r\n\r\n    /**\r\n     * Called once we have performed a full reconnection. Reconnect to the topic\r\n     * on the server and then fire off any reconnect callbacks registered on\r\n     * this topic.\r\n     */\r\n    private async reconnected(): Promise<void> {\r\n        await this.connect();\r\n\r\n        const serverProxy = createServerProxy<TServer>(this.engine, this.identifier, true);\r\n\r\n        for (const callback of this.reconnectCallbacks) {\r\n            try {\r\n                const result = callback(serverProxy);\r\n\r\n                if (isPromise(result)) {\r\n                    await result;\r\n                }\r\n            }\r\n            catch (error) {\r\n                console.error(error);\r\n            }\r\n        }\r\n    }\r\n}\r\n","// The module cache\nvar __webpack_module_cache__ = {};\n\n// The require function\nfunction __webpack_require__(moduleId) {\n\t// Check if module is in cache\n\tvar cachedModule = __webpack_module_cache__[moduleId];\n\tif (cachedModule !== undefined) {\n\t\treturn cachedModule.exports;\n\t}\n\t// Create a new module (and put it into the cache)\n\tvar module = __webpack_module_cache__[moduleId] = {\n\t\t// no module.id needed\n\t\t// no module.loaded needed\n\t\texports: {}\n\t};\n\n\t// Execute the module function\n\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n\t// Return the exports of the module\n\treturn module.exports;\n}\n\n","// startup\n// Load entry module and return exports\n// This entry module is referenced by other modules so it can't be inlined\nvar __webpack_exports__ = __webpack_require__(995);\n"],"names":["module","exports","jQuery","core_rspace","optionsCache","Callbacks","options","object","each","split","_","flag","createOptions","extend","memory","fired","firing","firingStart","firingLength","firingIndex","list","stack","once","fire","data","length","apply","stopOnFalse","shift","self","disable","add","start","args","arg","type","unique","has","push","arguments","this","remove","index","inArray","splice","fn","empty","undefined","disabled","lock","locked","fireWith","context","slice","obj","String","class2type","toString","call","isArray","isFunction","isPlainObject","callback","name","i","isObj","src","copy","copyIsArray","clone","target","deep","noop","Object","prototype","forEach","toLowerCase","core_slice","Array","Deferred","func","tuples","state","promise","always","deferred","done","fail","then","fns","newDefer","tuple","action","returned","resolve","reject","progress","notify","pipe","stateString","when","subordinate","progressValues","progressContexts","resolveContexts","resolveValues","remaining","updateFunc","contexts","values","value","notifyWith","resolveWith","global","param","a","s","rbracket","k","v","encodeURIComponent","buildParams","prefix","len","key","test","join","replace","n","all","Map","on","e","t","get","set","off","indexOf","emit","map","xhrObj","jQueryDeferred","jQueryParam","xhr","window","XMLHttpRequest","subject","events","load","handler","addEventListener","bind","event","unbind","removeEventListener","handlers","idx","current","concat","triggerHandler","_this","defaultAjaxHeaders","ajax","request","xhrFields","withCredentials","onreadystatechange","readyState","status","_hasError","error","success","JSON","parse","responseText","cacheBuster","Date","getTime","url","open","setRequestHeader","contentType","headers","keys","send","abort","reason","arr","item","trim","str","isEmptyObject","makeArray","support","cors","defineProperty","_typeof","Symbol","iterator","constructor","jQueryShim","$","resources","nojQuery","noTransportOnInit","errorOnNegotiate","stoppedWhileLoading","stoppedWhileNegotiating","errorParsingNegotiateResponse","errorRedirectionExceedsLimit","errorDuringStartRequest","errorFromServer","stoppedDuringStartRequest","errorParsingStartResponse","invalidStartResponse","protocolIncompatible","aspnetCoreSignalrServer","sendFailed","parseFailed","longPollFailed","eventSourceFailedToConnect","eventSourceError","webSocketClosed","pingServerFailedInvalidResponse","pingServerFailed","pingServerFailedStatusCode","pingServerFailedParse","noConnectionTransport","webSocketsInvalidState","reconnectTimeout","reconnectWindowTimeout","jsonpNotSupportedWithAccessToken","Error","_signalR","_connection","version","matches","_pageLoaded","document","_pageWindow","_negotiateAbortText","onStart","onStarting","onReceived","onError","onConnectionSlow","onReconnecting","onReconnect","onStateChanged","onDisconnect","changeState","connection","expectedState","newState","oldState","supportsKeepAlive","keepAliveData","activated","transport","addDefaultPort","protocol","match","getDefaultPort","ConnectingMessageBuffer","drainCallback","that","buffer","tryBuffer","message","signalR","connectionState","connecting","drain","connected","clear","qs","logging","init","defaultContentType","ieVersion","navigator","appName","exec","userAgent","parseFloat","source","transportError","format","firefoxMajorVersion","parseInt","configurePingInterval","config","onFail","pingIntervalId","pingInterval","setInterval","transports","_logic","pingServer","ajaxDefaults","processData","timeout","async","cache","isDisconnecting","disconnected","reconnecting","hub","$connection","lastError","connectingMessageBuffer","lastMessageAt","lastActiveAt","beatInterval","beatHandle","totalTransportConnectTimeout","redirectQs","_parseResponse","response","json","_originalJson","isCrossDomain","against","link","location","createElement","href","host","ajaxDataType","clientProtocol","supportedProtocols","negotiateRedirectSupportedProtocols","reconnectDelay","transportConnectTimeout","disconnectTimeout","reconnectWindow","keepAliveWarnAt","_initialize","waitForPageLoad","jsonp","_deferral","parser","setConnectionUrl","baseUrl","wsProtocol","log","requestedTransport","validateTransport","deferredStartHandler","stopReconnectingTimeout","onReconnectTimeout","configuredStopReconnectingTimeout","stop","setTimeout","stateChanged","clearTimeout","configureStopReconnectingTimeout","_originalUrl","initHandler","noTransportError","transportName","onFallback","isFirefox11OrGreater","monitorKeepAlive","startHeartbeat","res","protocolError","redirects","supportedTransports","negotiate","onFailed","err","negotiateRequest","prepareQueryString","onSuccess","_error","statusText","accessToken","result","availableTransports","ProtocolVersion","RedirectUrl","AccessToken","splitUrlAndQs","appRelativeUrl","Url","id","ConnectionId","token","ConnectionToken","webSocketServerUrl","WebSocketServerUrl","pollTimeout","ConnectionTimeout","DisconnectTimeout","TransportConnectTimeout","KeepAliveTimeout","timeoutWarning","TryWebSockets","starting","received","errorData","sendData","connectionSlow","reconnected","notifyServer","deferral","clearInterval","stopMonitoringKeepAlive","messageId","groupsToken","msg","m","console","toTimeString","debug","_log","noConflict","transportLogic","startAbortText","beat","monitoring","timeElapsed","lostConnection","userNotified","checkIfAlive","markActive","getAjaxUrl","path","InitHandler","startRequested","startCompleted","connectionStopped","failCalled","initReceived","transportFailed","transportTimeoutHandle","tryAbortStartRequest","ajaxStart","wrappedError","dataType","addQs","Response","_error2","preparedUrl","firstChar","appender","charAt","getUrl","poll","ajaxPost","Math","floor","random","maximizePersistentResponse","minPersistentResponse","MessageId","C","Messages","M","Initialized","S","ShouldReconnect","T","LongPollDelay","L","GroupsToken","G","E","updateGroups","stringifySend","stringify","ajaxSend","payload","triggerReceived","_error3","textStatus","ajaxAbort","rejectDeferred","triggerStartError","startRequest","_error4","tryInitialize","persistentResponse","onInitialized","processMessages","minData","I","markLastMessage","reconnectKeepAliveUpdate","verifyLastActive","isConnectedOrReconnecting","ensureReconnectingState","clearReconnectTimeout","reconnect","handleParseFailure","foreverFrame","count","connections","webSockets","socket","ex","opened","WebSocket","onopen","onclose","wasClean","onmessage","close","clearReconnectAttemptTimeout","reconnectAttemptTimeoutHandle","serverSentEvents","timeOut","eventSource","EventSource","Message","OPEN","eventPhase","CLOSED","loadingFixIntervalId","attachedTo","createFrame","frame","setAttribute","loadPreventer","prevent","tempFrame","body","appendChild","removeChild","cancel","iframeClearThreshold","frameId","frameLoadHandler","documentElement","attachEvent","receive","cw","frameMessageCount","contentWindow","contentDocument","firstChild","execCommand","parentNode","getConnection","started","longPolling","_fireConnect","tryFailConnect","privateData","reconnectErrors","fireReconnected","instance","reconnectTimeoutId","pollXhr","pollTimeoutId","raiseReconnect","polling","postData","onprogress","shouldReconnect","delay","min","pow","nextGuid","makeEventName","fun","thisp","hasOwnProperty","getArgValue","hasMembers","clearInvocationCallbacks","callbacks","invocationCallbacks","callbackId","invocationCallbackId","method","scope","isCallbackFromGeneratedHubProxy","hubProxy","hubConnection","hubName","settings","useDefaultPath","callbackMap","hasSubscriptions","eventName","callbackIdentity","isFromOldGeneratedHubProxy","_signalRGuid","registration","callbackSpace","guid","eventHandlers","callbackRegistration","j","invoke","methodName","argValues","H","A","d","minResult","_maximizeHubResponse","State","Progress","Data","progressjQueryVersionLogged","jquery","StackTrace","IsHubException","ErrorData","rejectWith","Result","minHubResponse","R","P","Id","D","proxies","proxy","dataCallbackId","_maximizeClientHubInvocation","Method","Hub","Args","errData","origData","minClientHubInvocation","_registerSubscribedHubs","_subscribedToHubs","subscribedHubs","createHubProxy","AspNetEngine","Engine","super","startConnection","Promise","onMessage","onTransportReconnecting","onTransportReconnect","onTransportDisconnect","closeConnection","topicIdentifier","messageName","messageParams","invokeCore","PromiseCompletionSource","internalPromise","resolvePromise","rejectPromise","startPromise","reconnectPromise","reconnectAttemptCount","reconnectTimer","reconnectCallbacks","disconnectCallbacks","isDisconnectedInternal","emitter","ensureConnected","isDisconnected","scheduleReconnectAttempt","attemptReconnect","getReconnectDelay","eventArgs","engine","getTopic","identifier","topic","Topic","connect","createServerProxy","skipReconnectingCheck","Proxy","propertyName","isReconnecting","server","connectionId","serverProxy","__webpack_module_cache__","__webpack_exports__","__webpack_require__","moduleId","cachedModule","__webpack_modules__"],"sourceRoot":""}